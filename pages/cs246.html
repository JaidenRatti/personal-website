<!DOCTYPE html>
<head>
    <link rel="stylesheet"  href="https://latex.now.sh/style.min.css" /> 
    <link rel="stylesheet" href="Home.module.css"/> 
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CS246</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #f9fafb;
    }
    body {
      margin: 0 auto;
      max-width: 800px;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
      font-weight: dark;
      line-height: 1.1;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    .topa {
        line-height: 0.6;
    }
    p.topa a{
        color: #a80000;
    }
    h1 {
        font-size: 1.5157em;
    }h2{
        font-size: 1.3195em; 
    } h3, h4, h5, h6 {
        line-height:1.2;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: rgb(235, 229, 229);
     overflow: visible;
     border-radius: 10px; 
    }
    .link {
        color: #a80000;
        text-decoration-color: #a80000; 
        line-height: 0.6;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
  <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js' type='text/javascript'></script>  
 </head><body>
</head>
<body>
<div class="titlepage">
<div class="center">
<p class="topa">_________________________________________________________</p>
<p class="topa">CS246: Object-Oriented Software Development</p>
<p class="topa">Prof. <a href="https://cs.uwaterloo.ca/~bmlushma/" target="_blank" class="link">Brad Lushman</a></p>
<p class="topa">1239</p>
<br />
</p>
</div>
</div>
<h1 class="unnumbered" id="lecture-1">Lecture 1</h1>
<h2 class="unnumbered" id="intro-to-c">Intro to C++</h2>
<p>In this course, we discuss the paradigm of object-oriented
programming from 3 perspectives:</p>
<ol>
<li><p>The programmer’s perspective - how to structure programs
correctly, and how to lower the risk of bugs</p></li>
<li><p>The compiler’s perspective - what do our constructions actually
mean, and what must the compiler do to support them?</p></li>
<li><p>The designer’s perspective - how can we use the tools that OOP
provides to build systems? Basic SE</p></li>
</ol>
<p><u>Assume knowledge of C from CS136</u></p>
<p>C:</p>
<div class="sourceCode" id="cb1" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Hello world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C++</p>
<div class="sourceCode" id="cb2" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>iostream<span class="op">&gt;;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span><span class="st">&quot;Hello world&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notes:</p>
<ul>
<li><p>main MUST return int - void main() illegal</p></li>
<li><p>return stmt - returns the status code to OS</p>
<ul>
<li><p>can be omitted from main (0 is assumed)</p></li>
</ul></li>
<li><p>stdio, printf still available in C++</p></li>
<li><p>preferred I/O header &lt;iostream&gt;</p>
<ul>
<li><p>std::cout <span class="math inline">≪</span> <span
class="math inline">≪</span> <span class="math inline">≪</span></p></li>
</ul></li>
<li><p>std::endl = end of line &amp; flush output buffer</p></li>
<li><p>using namespace std - lets your omit the std:: prefix</p></li>
</ul>
<p>To compile use: g++20h iostream (creates gcm.cache directory)</p>
<p>Then can compile program with: g++20m <span>file name</span></p>
<p>./a.out will display the program</p>
<p><u>Input/Output</u></p>
<p>3 I/O <u>streams</u></p>
<ul>
<li><p>cout/cerr — for printing to stdout/stderr</p></li>
<li><p>cin — reading from stdin</p></li>
</ul>
<p>I/O <u>operators</u></p>
<ul>
<li><p><span class="math inline">≪</span> "put to" (output)</p></li>
<li><p><span class="math inline">≫</span> "get from" (input)</p></li>
<li><p>cerr <span class="math inline">≪</span> x (produce value of x to
output, from x to screen)</p></li>
<li><p>cin <span class="math inline">≫</span> x (grab value of x from
input, from screen to x)</p></li>
</ul>
<p>E.g. add 2 numbers</p>
<div class="sourceCode" id="cb3" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>iostream<span class="op">&gt;;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> x <span class="op">&gt;&gt;</span> y<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> x<span class="op">+</span>y <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In terminal: g++20m plus.cc -o plus, ./plus, (enter two numbers)</p>
<p>By default, cin skips leading whitespace (space/tab/newline)</p>
<p>What if bad things hapen, eg</p>
<ul>
<li><p>input doesn’t contain an integer next</p></li>
<li><p>input too large/small to fit in a variable</p></li>
<li><p>out of input (EOF)</p></li>
</ul>
<p><u>Statement fails</u></p>
<p>If the read failed: cin.fail() will be true</p>
<p>If EOF: cin.fail(), cin.eof() both true</p>
<p>But not until the attempted read fails!</p>
<p><u>Ex</u> - read all ints from stdin &amp; echo them, one per line,
to stdout. Stop on bad input or eof</p>
<div class="sourceCode" id="cb4" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        cin<span class="op">&gt;&gt;</span>i<span class="op">:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cin<span class="op">.</span>fail<span class="op">())</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>i<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note:</p>
<ul>
<li><p>There is an implicit conversion from cin’s type (istream) to
bool</p></li>
<li><p>lets you use cin as a condition</p></li>
<li><p>cin converts to true, unless the stream has had a
failure</p></li>
</ul>
<div class="sourceCode" id="cb5" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">){</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        cin <span class="op">&gt;&gt;</span> i<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>cin<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>i<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note:</p>
<ul>
<li><p><span class="math inline">≫</span> is C’s (and C++’s) right
bitshift operator</p></li>
<li><p>If a &amp; b are ints, a<span class="math inline">≫</span>b
shifts a’s bits to right by b spots</p></li>
<li><p>e.g 21 <span class="math inline">≫</span> 3 21 = 10101 21 <span
class="math inline">≫</span> 3 = 2</p></li>
<li><p>But when the LHS is an istream (i.e cin), &gt;&gt; is the "get
from" operator</p></li>
<li><p>First example of overloading (same function has multiple
implementations)</p></li>
</ul>
<p>Recall:</p>
<ul>
<li><p>21 <span class="math inline">≫</span> 3 - bitshift</p></li>
<li><p>cin <span class="math inline">≫</span> x - input</p></li>
</ul>
<p>First example of overloading (same function/operator with multiple
implementations &amp; the compiler chooses the correct implementation
(at compile time)), based on the types of arguments.</p>
<h1 class="unnumbered" id="lecture-2">Lecture 2</h1>
<p>Operator <span class="math inline">≫</span></p>
<ul>
<li><p>inputs: cin (istream): placeholder for data (several possible
types)</p></li>
<li><p>output?: returns cin (istream)</p></li>
</ul>
<p>This is why we can write cin <span class="math inline">≫</span> x
<span class="math inline">≫</span> y <span class="math inline">≫</span>
z</p>
<p>Stepper (goes from left to right), where cin carries through the left
(cin&gt;&gt;x = cin, <span class="math inline">⟹</span> cin&gt;&gt;y
etc.)</p>
<div class="sourceCode" id="cb6" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">){</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>cin<span class="op">&gt;&gt;</span>i<span class="op">))</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>i<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Successful read, cin evaluates as true, evaluates as false if
otherwise.</p>
<p>Final Example</p>
<div class="sourceCode" id="cb7" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>cin<span class="op">&gt;&gt;</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>i<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Ex: Read all ints &amp; echo on stdout until EOF and skip non-integer
input.</p>
<div class="sourceCode" id="cb8" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!(</span>cin<span class="op">&gt;&gt;</span>i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>cin<span class="op">.</span>eof<span class="op">())</span> <span class="cf">break</span><span class="op">;</span> <span class="co">// done - eof</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            cin<span class="op">.</span>clear<span class="op">();</span> <span class="co">// Reset the streams failure flag</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            cin<span class="op">.</span>ignore<span class="op">();</span> <span class="co">// offending char is still in istream, remove</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> cout<span class="op">&lt;&lt;</span>i<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The stream will not function after failure until you do this
(clear).</p>
<div class="sourceCode" id="cb9" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="dv">95</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">// Prints 95</span></span></code></pre></div>
<p>What if we want to print a # in hexadecimal?</p>
<div class="sourceCode" id="cb10" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> hex <span class="op">&lt;&lt;</span> <span class="dv">95</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">//Prints 5f</span></span></code></pre></div>
<p>Hex is an I/O manipulator — puts stream into "hex mode" All
subsequent ints printed in hex.</p>
<p>To go back to decimal mode: cout <span class="math inline">≪</span>
dec;</p>
<p>Note that manipulators like hex and dec set flags in the standard
stream variables cout, etc. These are effectively global variables. I.e.
changes you make to these flags affect the whole program</p>
<p><strong>Good Practice:</strong> If you change a stream’s settings,
change them back when you are done</p>
<p><u>Strings</u></p>
<p>In C: array &amp; char (char* or char[]) terminated by <span
class="math inline">∖</span>0.</p>
<ul>
<li><p>Must explicitly manage memory — allocate more memory as strings
get longer.</p></li>
<li><p>Easy to overwrite the <span class="math inline">∖</span>0 &amp;
corrupt memory.</p></li>
</ul>
<p>C++ strings: import &lt;string&gt;, type std::string</p>
<ul>
<li><p>Grow as needed (no need to manage the memory)</p></li>
<li><p>Safer to manipulate</p></li>
</ul>
<p>e.g</p>
<div class="sourceCode" id="cb11" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>string s <span class="op">=</span> <span class="st">&quot;Hello&quot;</span><span class="op">;</span></span></code></pre></div>
<p>"Hello" — C style string (character array ["H","e","l","l",o",<span
class="math inline">∖</span>0]</p>
<p>s — C++ string created from the C string on initialization</p>
<p><u>String Operations</u></p>
<p>Equality/Inequality: <span
class="math inline"><em>s</em>1 =  = <em>s</em>2, <em>s</em>1! = <em>s</em>2</span></p>
<p>Comparisons: <span
class="math inline"><em>s</em>1 &lt;  = <em>s</em>2</span> etc.
(lexicographic)</p>
<p>Length: s.length() (it is <span
class="math inline"><em>O</em>(1)</span>)</p>
<p>Individual Characters: s[0], s[1], s[2], etc.</p>
<p>Concat: <span
class="math inline"><em>s</em>3 = <em>s</em>1 + <em>s</em>2, <em>s</em>3 +  = <em>s</em>4</span></p>
<div class="sourceCode" id="cb12" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">()</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    string s<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> s<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> s<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Skips leading white space &amp; stops at white space (i.e. read a
word). i.e. If given "hello world" to the above program, only returns
"hello".</p>
<p>What if we want the white space? getline(cin,s)</p>
<ul>
<li><p>reads from the current position to the next new line into
s</p></li>
</ul>
<p>Streams are an abstraction — they wrap an interface of "getting and
putting items" around the keyboard and screen.</p>
<p>Are there other kinds of "things" that could support this same
"getting &amp; putting" interface?</p>
<ol>
<li><p>File</p>
<ol>
<li><p>Read/write to/from a file instead of stdin/stdout</p></li>
<li><p>std::ifstream — a file stream for reading</p></li>
<li><p>std::ofstream — a file stream for writing</p></li>
</ol></li>
</ol>
<p><u>File access in C:</u></p>
<div class="sourceCode" id="cb13" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">256</span><span class="op">]</span> <span class="co">// Hoping no word is longer than 255 chars</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FILE</span> <span class="op">*</span>f <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;file.txt&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        fscanf<span class="op">(</span>f<span class="op">,</span> <span class="st">&quot;</span><span class="sc">%255s</span><span class="st">&quot;</span><span class="op">,</span>s<span class="op">);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>feof<span class="op">(</span>f<span class="op">))</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span>s<span class="op">);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    fclose<span class="op">(</span>f<span class="op">);</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>C++</u></p>
<div class="sourceCode" id="cb14" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>iostream<span class="op">&gt;;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>fstream<span class="op">&gt;;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>string<span class="op">&gt;;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span> </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    ifstream f <span class="op">{</span><span class="st">&quot;file.txt&quot;</span><span class="op">};</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    string s<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>f <span class="op">&gt;&gt;</span> s<span class="op">)</span> <span class="op">{</span> <span class="co">// using f the same way cin was</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>f</em>: Declaring &amp; initializing the ifstream var opens the
file.</p>
<p><mark>Important:</mark> The file (file.txt) is closed when f goes out
of scope.</p>
<p>Anything you can do with cin/cout, you can do with
ifstream/ofstream.</p>
<h1 class="unnumbered" id="lecture-3">Lecture 3</h1>
<p><u>Recall</u>: Other applications of the stream abstraction</p>
<ol>
<li><p>Files</p></li>
<li><p>Strings</p>
<ol>
<li><p>Extract data from chars in a string</p></li>
</ol>
<ol>
<li><p>Send data to a string as chars:</p>
<ol>
<li><p>std::ostringstream</p></li>
</ol></li>
</ol></li>
</ol>
<div class="sourceCode" id="cb15" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>sstream<span class="op">&gt;;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>string intToString<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    ostringstream sock<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    sock <span class="op">&lt;&lt;</span> n<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sock<span class="op">.</span>str<span class="op">();</span> <span class="co">// extract the string</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Convert string to #:</p>
<div class="sourceCode" id="cb16" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">){</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter a number&quot;</span><span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    string s<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> s<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>istringstream sock<span class="op">{</span>s<span class="op">};</span>sock<span class="op">&gt;&gt;</span>n<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sock has that string (s) in it</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// taking n out of it</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if successful, ends the loop, otherwise repeats</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span><span class="st">&quot;I said,&quot;</span><span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>cout<span class="op">&lt;&lt;</span><span class="st">&quot;You entered&quot;</span><span class="op">&lt;&lt;</span>n<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span></code></pre></div>
<p><u>Example Revisited:</u> Echo all #’s, skip non-#s</p>
<div class="sourceCode" id="cb17" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    string s<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>cin <span class="op">&gt;&gt;</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>istringstream sock<span class="op">{</span>s<span class="op">};</span> sock <span class="op">&gt;&gt;</span> n<span class="op">)</span>cout<span class="op">&lt;&lt;</span>n<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This program picks up 123abc (as 123), but def456 fails to read any
number.</p>
<p><u>Application:</u> Consider processing the command line.</p>
<p>To accept command line args in C or C++, always give main the
following params:</p>
<div class="sourceCode" id="cb18" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{..}</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">// int argc (count) is # of cmd line args</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">// &gt;= 1 (includes the program name itself)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">// int argv (vector) of c-style strings</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">// argv[0] = program name</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">// argv[1] = arg1, argv[2] = arg2 ...</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">// argv[argc] = null</span></span></code></pre></div>
<p>eg.</p>
<div class="sourceCode" id="cb19" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./myprogram</span> abc 123</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ex">//argc</span> = 3 </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ex">//</span> argv = [<span class="pp">[</span><span class="ss">./myprogram</span><span class="dt">\0</span><span class="pp">]</span>,<span class="pp">[</span><span class="ss">abc</span><span class="dt">\0</span><span class="pp">]</span>,<span class="pp">[</span><span class="ss">123</span><span class="dt">\0</span><span class="pp">]</span>] </span></code></pre></div>
<p><u>Note</u>: The args are stored as <u>C-style strings</u>.
<u>Recommendation:</u> Convert to C++ strings for processing</p>
<p><u>eg.</u></p>
<div class="sourceCode" id="cb20" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span><span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;</span>argc<span class="op">;++</span>i<span class="op">){</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        string arg <span class="op">=</span> argv<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>eg:</u> Print the sum of all numeric args on the cmd line</p>
<div class="sourceCode" id="cb21" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span>argc<span class="op">,</span><span class="dt">char</span><span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> argc<span class="op">;</span> <span class="op">++</span>i<span class="op">){</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        string arg <span class="op">=</span> argv<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>istringstream sock<span class="op">{</span>arg<span class="op">};</span> sock <span class="op">&gt;&gt;</span> n<span class="op">)</span> sum <span class="op">+=</span> n<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> sum <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Default Function Parameters</u></p>
<div class="sourceCode" id="cb22" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printWordsInFile<span class="op">(</span>string name <span class="op">=</span> <span class="st">&quot;words.txt&quot;</span><span class="op">){</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    ifstream file<span class="op">{</span>name<span class="op">};</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>string s<span class="op">;</span> file <span class="op">&gt;&gt;</span> s<span class="op">;)</span> cout<span class="op">&lt;&lt;</span>s<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>printWordsInFile<span class="op">(</span><span class="st">&quot;othername.txt&quot;</span><span class="op">);</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>printWordsInFile<span class="op">();</span> <span class="co">// prints from words.txt</span></span></code></pre></div>
<p><u>Note:</u> Optional parameters must be <strong>last</strong>.</p>
<p><u>Also note:</u> The missing parameter is supplied by the caller,
not by the function</p>
<p><u>Why?</u> The caller passes parameters by pushing them on the
stack. The function fetches parameters by reading them off the stack. If
a parameter is missing, the function as no way of knowing that. Would
interpret whatever is in that part of the stack as the argument.</p>
<p>So instead, the <u>caller</u> must supply the extra parameter if it
is missing. <span class="math inline">∴</span> when you write
printWordsInFile(); The compiler replaces this with
printWordsInFile("words.txt")</p>
<p>For this reason, default arguments are part of a function’s
<u>interface</u>, rather than its implementation.</p>
<p><span class="math inline">∴</span> defaults go in the interface file,
not the implementation file.</p>
<p><u>Overloading</u></p>
<p><u>C:</u></p>
<div class="sourceCode" id="cb23" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> negInt<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span><span class="cf">return</span> <span class="op">-</span>n<span class="op">;}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> negBool<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> <span class="op">!</span>b<span class="op">;}</span></span></code></pre></div>
<p><u>C++</u>: Functions with different parameter lists can share the
same name</p>
<div class="sourceCode" id="cb24" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> neg<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> <span class="op">-</span>n<span class="op">;}</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> neg<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> <span class="op">!</span>b<span class="op">;}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">// referred to as overloading</span></span></code></pre></div>
<p>Correct version of neg, for each function call, is chosen <u>by the
compiler</u> (i.e at <u>compile-time)</u> based on the # and type of
arguments in the function call.</p>
<p><span class="math inline">neg(4) =  − 4</span>, <span
class="math inline">neg(<em>t</em><em>r</em><em>u</em><em>e</em>) = <em>f</em><em>a</em><em>l</em><em>s</em><em>e</em></span></p>
<p><span class="math inline">∴</span> overloads must differ in #/types
of arguments — just differing in the return type is not enough.</p>
<p>We’ve seen this already: <span class="math inline"> = =</span>
(ints/strings) <span class="math inline">≫</span> (shift/I/O)</p>
<p><u>Structures</u></p>
<div class="sourceCode" id="cb25" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// no longer need struct Node *next from C</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span> <span class="co">// don&#39;t forget the semicolon.</span></span></code></pre></div>
<p><u>Constants</u></p>
<div class="sourceCode" id="cb26" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> maxGrade <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> <span class="co">// must be initialized</span></span></code></pre></div>
<p>Declare as many things constant as you can — helps catch errors</p>
<div class="sourceCode" id="cb27" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>Node n <span class="op">{</span><span class="dv">5</span><span class="op">,</span><span class="kw">nullptr</span><span class="op">};</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">//syntax for null pointers in C++</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Do not say NULL in this course</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Node n2 <span class="op">=</span> n<span class="op">;</span> <span class="co">// immutable copy of n</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">// cannot mutate the fields</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-4">Lecture 4</h1>
<p><u>Parameter Passing</u></p>
<p><u>Recall</u></p>
<div class="sourceCode" id="cb28" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> inc<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="op">++</span>n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>inc<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> x<span class="op">;;</span> <span class="co">// returns 5</span></span></code></pre></div>
<p>Pass-by-value — inc gets a <u>copy</u> of x, mutates the copy. Thus
the original is unchanged</p>
<p><u>Solution</u>: If a function needs to mutate an argument, you pass
a pointer.</p>
<div class="sourceCode" id="cb29" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> inc <span class="op">(</span><span class="dt">int</span> <span class="op">*</span>n<span class="op">)</span> <span class="op">{</span> <span class="op">++*</span>n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>inc<span class="op">(&amp;</span>x<span class="op">);</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> x<span class="op">;</span> <span class="co">// returns 6</span></span></code></pre></div>
<p>X’s address is being passed by value. Increment changes the data
address. Now visible to the caller.</p>
<p><u>Q</u>:</p>
<div class="sourceCode" id="cb30" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,&amp;</span>x<span class="op">);</span></span></code></pre></div>
<p>Why cin <span class="math inline">≫</span> x and not cin <span
class="math inline">≫</span> &amp;x?</p>
<p><u>A</u>: C++ has another pointer-like type, <u>reference</u>.</p>
<p><u>References (<strong>Important)</strong></u></p>
<div class="sourceCode" id="cb31" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">&amp;</span>z <span class="op">=</span> y<span class="op">;</span> <span class="co">//z is an lvalue reference to y (int)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">// like a constant pointer - similar to saying int *const z = &amp;y;</span></span></code></pre></div>
<p>References are like constant pointers with automatic
dereferencing.</p>
<p>y [10]</p>
<p>z [pointer to y (arrow to 10)]</p>
<p>z [] can’t change. Once pointing to y, it can’t change.</p>
<p><em>If the const was on the other side of the =, then y would be
constant.</em></p>
<p>z = 12; (<u>NOT</u> *z=12)</p>
<p>z = 12 <strong>changes</strong> the value associated with y
(y[10]<span class="math inline">→</span> y[12]) now y == 12</p>
<p>int *p = &amp;z;</p>
<p>Address of z gives the address of y.</p>
<p>In all cases, z acts exactly like y. Whatever changes happen to z are
going to happen to y.</p>
<p>Z is an <u>alias</u> ("another name") for y.</p>
<p><u>Q</u>: How can we tell when &amp; means "reference" and when it
means "address of".</p>
<p><u>A</u>:</p>
<p>Whenever &amp; occurs as part of a type (eg int &amp;z). It
<u>always</u> means reference.</p>
<p>When &amp; occurs in an expression, it means "address of". (or
bitwise -and).</p>
<p>lvalue, rvalue x = y; Interested in the value of y, and the
address/location of x (not it’s value).</p>
<p>Things you <u>can’t do</u> with lvalue refs:</p>
<ul>
<li><p>Leave them uninitialized e.g. int &amp;x;</p>
<ul>
<li><p><u>Must</u> be initialized with something that has an address (an
<u>lvalue</u>).</p></li>
</ul>
<div class="itemize">
<ul>
<li><p>int &amp;x = 3; is illegal. (3 doesn’t have a location)</p></li>
</ul>
<ul>
<li><p>int &amp;x = y + z; is illegal (value of y + z has no
location)</p></li>
</ul>
<ul>
<li><p>int &amp;x = y; is <mark>legal</mark></p></li>
</ul>
</div></li>
<li><p>Create a pointer to a reference</p>
<ul>
<li><p>int &amp;*p; (start at the variable work backwards)</p>
<ul>
<li><p>int *&amp;p = ; is <mark>legal</mark></p></li>
</ul></li>
</ul></li>
<li><p>Create a reference to a reference</p>
<ul>
<li><p>int &amp;&amp;r = ; is illegal</p>
<ul>
<li><p>denotes something different (later)</p></li>
</ul></li>
</ul></li>
<li><p>Create an array of references</p>
<ul>
<li><p>int &amp;r[3] = {, , ,}; is illegal</p></li>
</ul></li>
</ul>
<p>What <u>can</u> you do?</p>
<ul>
<li><p>pass as function parameters</p></li>
</ul>
<div class="sourceCode" id="cb32" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> inc <span class="op">(</span><span class="dt">int</span> <span class="op">&amp;</span>n<span class="op">)</span> <span class="op">{</span> <span class="op">++</span>n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>inc<span class="op">(</span>x<span class="op">);</span> <span class="co">//don&#39;t do anything special to x</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">// 6</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">//no pointer dereference</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">//constant pointer to the argument x</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">//IT IS X</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co">//changes affect x</span></span></code></pre></div>
<p>Why does cin <span class="math inline">≫</span> x work? Takes x as a
reference.</p>
<div class="sourceCode" id="cb33" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>istream <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&gt;&gt;(</span>istream<span class="op">&amp;</span>in<span class="op">,</span> <span class="dt">int</span> <span class="op">&amp;</span>n<span class="op">);</span></span></code></pre></div>
<p><u>Q</u>: Why is the stream being taken &amp; returned as a
reference? And what does returning by reference mean?</p>
<p><u>A</u>: We need a better understanding of pass-by-value</p>
<p><u>Pass-by-Value</u></p>
<p>Pass-by-value, e.g. int f (int n) { ... } copies the argument.</p>
<p>If the parameter is big, the copy is expensive</p>
<div class="sourceCode" id="cb34" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ReallyBig<span class="op">{...};</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>ReallyBig rb<span class="op">);</span> <span class="co">// copies rb, slow</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">(</span>ReallyBig <span class="op">&amp;</span>rb<span class="op">);</span> <span class="co">// alist-fast, but g may be change rb</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h<span class="op">(</span><span class="at">const</span> ReallyBig <span class="op">&amp;</span>rb<span class="op">);</span> <span class="co">//fast, no copy, parameter cannot be changed.</span></span></code></pre></div>
<p>But what if a function <u>does</u> want to make changes to rb
locally, but doesn’t want these changes to be visible to the caller?</p>
<p>Then the function must make a copy of rb.</p>
<div class="sourceCode" id="cb35" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> k<span class="op">(</span><span class="at">const</span> ReallyBig <span class="op">&amp;</span>rb<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    ReallyBig rb2 <span class="op">=</span> rb<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// mutate rb2</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But if you have to make a copy anyway, it is better to just use
pass-by-value &amp; have the compiler make it for you. It might be able
to optimize something.</p>
<p><u>Advice:</u> Prefer pass-by-const-ref over pass-by-value for
anything larger than a pointer. Unless the function needs to make a copy
anyway, then use pass-by-value.</p>
<p>Also:</p>
<div class="sourceCode" id="cb36" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">// illegal</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">//can&#39;t initialize an lvalue reference (n) to a literal value (non lvalue)</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">//if n changes, can&#39;t change the literal 5</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>g<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">// OK - since n can never be changed. The compiler allows this</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">//5 currently stored in a temporary location on the stack.</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">//So n can point there.</span></span></code></pre></div>
<p>So in the case of</p>
<div class="sourceCode" id="cb37" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>istream <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&gt;&gt;(</span>istream<span class="op">&amp;</span>in<span class="op">,</span> <span class="dt">int</span> <span class="op">&amp;</span>n<span class="op">);</span></span></code></pre></div>
<p>the istream is being passed (and returned) by reference to save
copying.</p>
<p>This is important because stream variables are not allowed to be
copied. <u>Dynamic Memory Allocation</u></p>
<p><u>C:</u></p>
<div class="sourceCode" id="cb38" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> malloc<span class="op">(</span>x<span class="op">*</span>sizeofint<span class="op">);</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>free<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">// DON&quot;T USE THESE IN C++!</span></span></code></pre></div>
<p>Instead: new/delete. Type-aware, less error prone.</p>
<div class="sourceCode" id="cb39" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>np <span class="op">=</span> <span class="kw">new</span> Node<span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> np<span class="op">;</span></span></code></pre></div>
<p>Stack includes np Heap includes Node np points to Node.</p>
<h1 class="unnumbered" id="lecture-5">Lecture 5</h1>
<p><u>Recall:</u></p>
<div class="sourceCode" id="cb40" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>np <span class="op">=</span> <span class="kw">new</span> Node<span class="op">;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> np<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co">// np is in stack, pointing to..</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Node is in heap</span></span></code></pre></div>
<ul>
<li><p>All local variables reside on the stack.</p>
<ul>
<li><p>Variables are deallocated when they go out of scope (stack is
popped)</p></li>
</ul></li>
<li><p>Allocated memory resides in the heap</p>
<ul>
<li><p>Remains allocated until delete is called</p></li>
</ul></li>
<li><p>If you don’t delete all allocated memory — <u>memory leak</u></p>
<ul>
<li><p>Program will eventually fail — we regard this as an incorrect
program</p></li>
</ul></li>
</ul>
<p><u>Arrays</u></p>
<div class="sourceCode" id="cb41" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>nodeArray <span class="op">=</span> <span class="kw">new</span> Node<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> <span class="op">[]</span> nodeArray<span class="op">;</span></span></code></pre></div>
<p>Memory allocated with new must be deallocated with delete.</p>
<p>Memory allocated with new [...] must be deallocated with delete
[].</p>
<p>Missing these <span class="math inline">=</span> Undefined Behaviour
(<strong>UB</strong>)</p>
<p><u>Returning by Value/Ptr/Ref</u></p>
<div class="sourceCode" id="cb42" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>Node getMeANode<span class="op">()</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    Node n<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Expensive, n is copied to the caller&#39;s </span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">// stack frame on return</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Return a pointer (or ref) instead?</span></span></code></pre></div>
<div class="sourceCode" id="cb43" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>getMeANode<span class="op">()</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    Node n<span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>n<span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="co">// BAD (one of worst things can do)</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Returns a pointer to stack allocated memory</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Which is dead on return. (UB)</span></span></code></pre></div>
<div class="sourceCode" id="cb44" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">&amp;</span>getMeANode<span class="op">()</span> <span class="op">{</span> <span class="co">//Also bad - same reason</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    Node n<span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Q</u>: Why was it OK for operator <span
class="math inline">≫</span> to return an istream reference</p>
<p><u>A</u>: Because the reference is not to a local variable. The
returned reference is the same reference that was passed as the
parameter "in", so it refers to something accessible to the caller.</p>
<div class="sourceCode" id="cb45" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>getMeANode<span class="op">()</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>np <span class="op">=</span> <span class="kw">new</span> Node<span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np<span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co">// OK 0 returns a pointer to heap data (still alive)</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">// But don&#39;t forget to delete it when done with it</span></span></code></pre></div>
<p>Which should you pick? Return by value. Often not as expensive as it
looks (we will see why later).</p>
<p><u>Operator Overloading</u></p>
<p>Can give meanings to C++ operators for types we create</p>
<p><u>E.g.</u></p>
<div class="sourceCode" id="cb46" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    Vec v<span class="op">{</span>v1<span class="op">.</span>x<span class="op">+</span>v2<span class="op">.</span>x<span class="op">,</span> v1<span class="op">.</span>y<span class="op">+</span>v2<span class="op">.</span>y<span class="op">};</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v<span class="op">){</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>k<span class="op">*</span>v<span class="op">.</span>x<span class="op">,</span>k<span class="op">*</span>v<span class="op">,</span>y<span class="op">};</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// OK because the compiler knows it&#39;s a vector, based on the</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// return type</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v<span class="op">,</span> <span class="at">const</span> in k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> k<span class="op">*</span>v<span class="op">;</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// calling the above function</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a><span class="co">// now will work when Vec v4 {2 * v1} AND Vec v5 {v1 * 2}</span></span></code></pre></div>
<p>Special Case: Overloading <span class="math inline">≫</span> and
<span class="math inline">≪</span></p>
<div class="sourceCode" id="cb47" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Grade <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> theGrade<span class="op">;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>ostream <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&lt;&lt;(</span>ostream <span class="op">&amp;</span>out<span class="op">,</span> <span class="at">const</span> Grade <span class="op">&amp;</span>g<span class="op">){</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> g<span class="op">.</span>theGrade <span class="op">&lt;&lt;</span> <span class="ch">&#39;%&#39;</span><span class="op">;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>istream <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&gt;&gt;(</span>istream<span class="op">&amp;</span>in<span class="op">,</span> Grade <span class="op">&amp;</span>g<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    in <span class="op">&gt;&gt;</span> g<span class="op">.</span>theGrade<span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>g<span class="op">.</span>theGrade <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> g<span class="op">.</span>theGrade <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>g<span class="op">.</span>theGrade <span class="op">&gt;</span> <span class="dv">100</span><span class="op">)</span> g<span class="op">.</span>theGrade <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> in<span class="op">;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    Grade g<span class="op">;</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>cin <span class="op">&gt;&gt;</span> g<span class="op">)</span> cout <span class="op">&lt;&lt;</span> g <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Separate Compilation</u></p>
<p>Split programs into <u>modules</u>, which each provide</p>
<ul>
<li><p><u>interface</u> — type definitions, function headers</p></li>
<li><p><u>implementation</u> — full definition for every provided
function</p></li>
</ul>
<p><u>Recall</u>: declaration — asserts existence definition — full
details — allocates space (variables / functions)</p>
<p><u>E.g</u>: Interface (vec.cc)</p>
<div class="sourceCode" id="cb48" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> <span class="kw">module</span> vec<span class="op">;</span> <span class="co">// Indicates that this is the module interface file.</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> <span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Anything marked &quot;export&quot; is available for the client to use</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> Vec <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">);</span></span></code></pre></div>
<p>main.cc</p>
<div class="sourceCode" id="cb49" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> vec<span class="op">;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    Vec v<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> v<span class="op">+</span>v<span class="op">;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Implementation: vec-impl.cc (see line 9 in interface block)</p>
<div class="sourceCode" id="cb50" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> vec<span class="op">;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Thie file is part of module vec</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Implicitly importrs the interface</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> vec <span class="op">&amp;</span>v2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>v1<span class="op">.</span>x<span class="op">+</span>v2<span class="op">.</span>x<span class="op">,</span> v1<span class="op">.</span>y<span class="op">+</span>v2<span class="op">.</span>y<span class="op">}</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Recall</u>: An entity can be declared many times, but defined only
once.</p>
<p>Interface files: start with export module ....; Implementation files:
start with module ....;</p>
<p>Compiling separately: g++ <u><u>-c</u></u> ...cc</p>
<p>Above says, compile only, do not link, do not build exec.</p>
<p>Produces an object file (.o)</p>
<p><em>g++20m -c vec.cc</em></p>
<p><em>g++20m -c vec-impl.cc</em></p>
<p><em>g++20m -c main.cc</em></p>
<p><em>g++20m vec.o vec.-impl.o main.o -o main</em></p>
<p><em>./main</em> Must be in dependency order</p>
<p>Dependency order: interface must be compiled before implementation,
client.</p>
<p>Build tool support for compiling in dependency order (e.g. make) is
still a work in progress.</p>
<h1 class="unnumbered" id="lecture-6">Lecture 6</h1>
<p><u>Classes</u></p>
<p>Can put functions inside of structs.</p>
<p><u>e.g</u>: student.cc</p>
<div class="sourceCode" id="cb51" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> <span class="kw">struct</span> Student<span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> assns<span class="op">,</span> mt<span class="op">,</span> <span class="kw">final</span><span class="op">;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grade<span class="op">();</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>student-impl.cc</p>
<div class="sourceCode" id="cb52" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> Student<span class="op">::</span>grade <span class="op">()</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> assns<span class="op">*</span><span class="fl">0.4</span><span class="op">+</span>mt<span class="op">*</span><span class="fl">0.2</span><span class="op">+</span><span class="kw">final</span><span class="op">*</span><span class="fl">0.4</span><span class="op">;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>client</u></p>
<div class="sourceCode" id="cb53" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>Student s <span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> s<span class="op">.</span>grade<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span></code></pre></div>
<p>A class is essentially a struct type that can contain function. C++
does have a specific class keyword (later).</p>
<p>An object is an instance of a class.</p>
<div class="sourceCode" id="cb54" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>Student s <span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Student is the class, s is the object</span></span></code></pre></div>
<p>The function grade is a <u>member function</u> or (<u>method</u>)</p>
<p>:: is called the <u>scope resolution operator</u>.</p>
<p>C::f means f in the context of class C.</p>
<p>:: like . where LHS is a class (or namespace), not an obj.</p>
<p>What do assns, mt, final mean inside of Student::grade?</p>
<ul>
<li><p>They are fields of the <u>receiver</u> objects — the object upon
which the method was called</p></li>
<li><p>e.g s.grade() is a method call that uses s’s assns, int,
final</p></li>
</ul>
<p>Formally: methods take a hidden extra parameter called <u>this</u> —
pointer to the receiver object.</p>
<p>e.g s.grade(); within grade(), <span
class="math inline"><em>t</em><em>h</em><em>i</em><em>s</em> =  = &amp;<em>s</em></span></p>
<p>Can write</p>
<div class="sourceCode" id="cb55" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student<span class="op">{</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grade<span class="op">()</span> <span class="op">{</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>assns<span class="op">*</span><span class="fl">0.4</span><span class="op">+</span><span class="kw">this</span><span class="op">-&gt;</span>mt<span class="op">*</span><span class="fl">0.2</span> <span class="op">+</span> <span class="kw">this</span><span class="op">-&gt;</span><span class="kw">final</span><span class="op">*</span><span class="fl">0.4</span><span class="op">;</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>(Methods can be written in the class. We will often do this for
brevity. You should put impls in a separate file).</p>
<p><u>Initialization Objects</u></p>
<div class="sourceCode" id="cb56" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>Student s<span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span> <span class="co">// OK, but limited</span></span></code></pre></div>
<p><u>Better</u> — write a method that initializes a <u>constructor</u>
(ctor)</p>
<div class="sourceCode" id="cb57" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> assns<span class="op">,</span> mt<span class="op">,</span> <span class="kw">final</span><span class="op">;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grade<span class="op">();</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    Student <span class="op">(</span><span class="dt">int</span> assns<span class="op">,</span><span class="dt">int</span> mt<span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">);</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb58" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>Student<span class="op">::</span>Student <span class="op">(</span><span class="dt">int</span> assns<span class="op">,</span> <span class="dt">int</span> mt<span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>assns <span class="op">=</span> assns<span class="op">;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>mt <span class="op">=</span> mt<span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span><span class="kw">final</span> <span class="op">=</span> <span class="kw">final</span><span class="op">;</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>Student s<span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span> <span class="co">// better</span></span></code></pre></div>
<p>If a constructor has been defined, these are passed as arguments to
the constructor. If no constructor has been defined, it is C-style
field-by-field initialization. C-style is only available if you have not
written a constructor.</p>
<p>Alternative syntax: Student s = Student{60,70,80};</p>
<p>Looks like construction of an anonymous student obj (i.e
Student{60,70,80}) which is then copied to initialize s.</p>
<p>But it is not — semantically identical to Student s {60,70,80}; More
on this later</p>
<p>Advantages of ctors: they’re functions!</p>
<ul>
<li><p>Can write arbitrarily complex initialization code</p></li>
<li><p>Default parameters, overloading, sanity checks</p></li>
</ul>
<p><u>e.g</u></p>
<div class="sourceCode" id="cb59" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student<span class="op">{</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    Student <span class="op">(</span><span class="dt">int</span> assns<span class="op">=</span><span class="dv">0</span><span class="op">,</span> <span class="dt">int</span> mt<span class="op">=</span><span class="dv">0</span><span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">=</span><span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>assns<span class="op">=</span>assns<span class="op">;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb60" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>Student s2<span class="op">{</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span> <span class="co">// 70,80,0</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>Student newKid<span class="op">;</span> <span class="co">// 0,0,0</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Student newKid{}; and Student newKid; are identical</span></span></code></pre></div>
<p>It may look like Student newKid; calls a ctor, and Student newKid;
does not. That is not correct. Whenever an object is created, a ctor is
<u>always</u> called.</p>
<p><u>Q</u>: What if you didn’t write one? e.g Vec v;</p>
<p><u>A</u>: Every class comes with a default <u>(i.e zero-arg) ctor</u>
(which just default-constructs all fields that are objects).</p>
<p><u>e.g</u></p>
<div class="sourceCode" id="cb61" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>Vec v<span class="op">;</span> <span class="co">// default ctor (does nothing in this case)</span></span></code></pre></div>
<p>But the built-in default constructor goes away if you write any
constructor.</p>
<p><u>e.g</u></p>
<div class="sourceCode" id="cb62" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec<span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    Vec <span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>x <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>y <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>Vec v<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">}</span> <span class="co">// OK</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>Vec v<span class="op">;</span> <span class="co">// Erorr, doesn&#39;t compile</span></span></code></pre></div>
<p>Continue with this definition for now.</p>
<p>Now consider:</p>
<div class="sourceCode" id="cb63" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Basis <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    Vec v1<span class="op">,</span>v2<span class="op">;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>Basis b<span class="op">;</span> <span class="co">// Won&#39;t compile</span></span></code></pre></div>
<p>The built-in default ctor for Basis wants to default-construct all
fields that are objects. v1, v2 are objects, but they have no default
ctor. So basis cannot have a built-in default ctor.</p>
<p>Could we write our own?</p>
<div class="sourceCode" id="cb64" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Basis <span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    Vec v1<span class="op">,</span> v2<span class="op">;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    Basis <span class="op">()</span> <span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        v1 <span class="op">=</span> Vec<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> Vec<span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This also does not work. Why? Too late. The body of the ctor can
contain arbitrary code, so the fields of the class are expected to be
constructed and ready to use before the constructor body runs.</p>
<p><u>Object Creation Steps</u></p>
<p>When an object is created: 3 steps</p>
<ol>
<li><p>Space is allocated</p></li>
<li><p>Fields are constructed in declaration order (i.e ctors run for
fields that are objects)</p></li>
<li><p>Ctor body runs</p></li>
</ol>
<p>Initialization (i.e. construction) of v1, v2 must happen in step 2,
not step 3. How can we accomplish this?</p>
<p><u>Member Initialization List (MIL)</u></p>
<div class="sourceCode" id="cb65" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>Student<span class="op">::</span>Student<span class="op">(</span><span class="dt">int</span> assns<span class="op">,</span> <span class="dt">int</span> mt<span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">):</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    assns<span class="op">{</span>assns<span class="op">},</span> mt<span class="op">{</span>mt<span class="op">},</span> <span class="kw">final</span><span class="op">{</span><span class="kw">final</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// step 2                       // step 3</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// outside of {x} needs to be fields, inside are all parameters</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-7">Lecture 7</h1>
<p>Recall: Member Initialization List (MIL)</p>
<div class="sourceCode" id="cb66" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>Student<span class="op">::</span>Student<span class="op">(</span><span class="dt">int</span> assns<span class="op">,</span> <span class="dt">int</span> mt<span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">):</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    assns<span class="op">{</span>assns<span class="op">},</span> mt<span class="op">{</span>mt<span class="op">},</span> <span class="kw">final</span><span class="op">{</span><span class="kw">final</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// step 2                       // step 3</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// outside of {x} needs to be fields, inside are all parameters</span></span></code></pre></div>
<p><u>Note</u>: can initialize <u>any</u> field this way, not just
object fields.</p>
<div class="sourceCode" id="cb67" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Basis <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    Vec v1<span class="op">,</span> v2<span class="op">;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    Basis<span class="op">():</span> v1<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">},</span> v2<span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">}{}</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Step 1: v1{1,0}, v2{0,1}</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Step 2: {}</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    Basis<span class="op">(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">):</span> v1<span class="op">{</span>v1<span class="op">},</span>v2<span class="op">{</span>v2<span class="op">}{}</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="co">// What ctor for Vec is being called here?</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>Default values for the MIL</u></p>
<div class="sourceCode" id="cb68" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Basis <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    Vec v1<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">},</span>v2<span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">};</span> <span class="co">// If an MIL does not mention a field, </span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// these values will be used</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    Basis<span class="op">(){}</span> <span class="co">// uses default values</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    Basis<span class="op">(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">):</span> v1<span class="op">{</span>v1<span class="op">},</span>v2<span class="op">{</span>v2<span class="op">}{}</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Note</u>:</p>
<p>Fields are initialized in <u>the order in which they were declared in
the class</u>, even if the MIL orders them differently.</p>
<p>MIL: sometimes more efficient than setting fields in a constructor
body</p>
<p>Consider:</p>
<div class="sourceCode" id="cb69" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student<span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> assns<span class="op">,</span>mt<span class="op">,</span><span class="kw">final</span><span class="op">;</span> <span class="co">// not objects</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    string name<span class="op">;</span> <span class="co">// object</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    student<span class="op">(</span><span class="dt">int</span> assns<span class="op">,</span><span class="dt">int</span> mt<span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">,</span> string name<span class="op">){</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>assns <span class="op">=</span> assns<span class="op">;</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>mt <span class="op">=</span> mt<span class="op">;</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span><span class="kw">final</span> <span class="op">=</span> <span class="kw">final</span><span class="op">;</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>name <span class="op">=</span> name<span class="op">;</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Name default-constructed (to the empty string) in step 2 and
reassigned it.</p>
<p>Versus</p>
<div class="sourceCode" id="cb70" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>Student <span class="op">(</span><span class="dt">int</span> assns<span class="op">,</span> <span class="dt">int</span> mt<span class="op">,</span> <span class="dt">int</span> <span class="kw">final</span><span class="op">,</span> string name<span class="op">):</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>assns<span class="op">{</span>assns<span class="op">},</span> mt<span class="op">{</span>mt<span class="op">},</span> <span class="kw">final</span><span class="op">{</span><span class="kw">final</span><span class="op">},</span> name<span class="op">{</span>name<span class="op">}{}</span></span></code></pre></div>
<p>Name is initialized to the correct value from the beginning in step
2, and there is no reassignment in step 3.</p>
<p>More efficient.</p>
<p>MIL <u>must</u> be used:</p>
<ul>
<li><p>For fields that are objects with no default ctor</p></li>
<li><p>For fields that are constant or references</p></li>
</ul>
<p>MIL <u>should</u> be used as much as possible. Embrace MIL.</p>
<p>Recall once again:</p>
<div class="sourceCode" id="cb71" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>Basis<span class="op">::</span>Basis <span class="op">(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">):</span> v1<span class="op">{</span>v1<span class="op">},</span>v2<span class="op">{</span>v2<span class="op">}{}</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Consider</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>Student s <span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>Student s2 <span class="op">=</span> s<span class="op">;</span></span></code></pre></div>
<p>How does this initialization happen?</p>
<ul>
<li><p>The <u>copy constructor</u></p></li>
<li><p>For constructing one object as a copy of another</p></li>
</ul>
<p><u>Note</u>: Every class comes with</p>
<ul>
<li><p>default ctor (default-constructs all fields that are objects)</p>
<ul>
<li><p>lost if you write any ctor</p></li>
</ul></li>
<li><p>copy ctor (just copies all fields)</p></li>
<li><p>copy assignment operator</p></li>
<li><p>destructor</p></li>
<li><p>move ctor</p></li>
<li><p>move assignment operator</p></li>
</ul>
<p>Building your own copy ctor:</p>
<div class="sourceCode" id="cb72" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student<span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> assns<span class="op">,</span> mt<span class="op">,</span> <span class="kw">final</span><span class="op">;</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    Student <span class="op">(</span><span class="at">const</span> Student <span class="op">&amp;</span>other<span class="op">):</span>assns<span class="op">{</span>other<span class="op">.</span>assns<span class="op">},</span>mt<span class="op">{</span>other<span class="op">.</span>mt<span class="op">},</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">final</span><span class="op">{</span>other<span class="op">.</span><span class="kw">final</span><span class="op">}{}</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span> <span class="co">// equivalent to built-in</span></span></code></pre></div>
<p>When is the built-in copy ctor not correct?</p>
<p>Consider:</p>
<div class="sourceCode" id="cb73" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">,</span> </span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>n <span class="op">=</span> <span class="kw">new</span> Node<span class="op">{</span><span class="dv">1</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">2</span><span class="op">,</span>newNode<span class="op">{},{</span><span class="dv">3</span><span class="op">,</span><span class="kw">nullptr</span><span class="op">}}};</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>Node m <span class="op">=</span> <span class="op">*</span>n<span class="op">;</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>p <span class="op">=</span> <span class="kw">new</span> Node<span class="op">{*</span>n<span class="op">};</span> <span class="co">// copy ctor</span></span></code></pre></div>
<p>p points to 1 on the heap which points to 2 also on the heap</p>
<p>Simple copy of fields <span class="math inline">→</span> only the
first node is actually copied. (shallow copy).</p>
<p>If you want a deep copy (copies the whole list), must write your own
copy ctor:</p>
<div class="sourceCode" id="cb74" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span><span class="at">const</span> Node <span class="op">&amp;</span>other<span class="op">):</span> data<span class="op">{</span>other<span class="op">.</span>data<span class="op">},</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    next<span class="op">{</span>other<span class="op">.</span>next <span class="op">?</span> <span class="kw">new</span> Node <span class="op">{*</span>other<span class="op">.</span>next<span class="op">}</span> <span class="op">:</span> <span class="kw">nullptr</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="co">// new Node {*other.next} recursively copies the rest of the list</span></span></code></pre></div>
<p>The copy ctor is called:</p>
<ol>
<li><p>When an object is initialized by another object of the same
type</p></li>
<li><p>When an object is passed by value</p></li>
<li><p>When an object is returned by value</p></li>
</ol>
<p>The truth is more nuanced, as we will see.</p>
<p><u>Q</u>: Why is this wrong:</p>
<div class="sourceCode" id="cb75" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">,</span> </span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span>node other<span class="op">):</span>___<span class="op">{}</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>A</u>: Taking ‘other’ by value means ‘other’ is being copied, so
the copy ctor must be called before we can begin executing the copy ctor
(<span class="math inline">∞</span> recursion).</p>
<p><u>Note</u>: Careful with ctors that can take <u>one</u>
argument:</p>
<div class="sourceCode" id="cb76" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">,</span> </span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span><span class="dt">int</span> data<span class="op">,</span> Node <span class="op">*</span>next<span class="op">=</span><span class="kw">nullptr</span><span class="op">):</span> data<span class="op">{</span>data<span class="op">},</span>next<span class="op">{</span>next<span class="op">}{}</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Single-arg ctors create implicit conversions:</p>
<p><u>E.g</u> Node n<span>4</span>;</p>
<p>but also Node n = 4; implicit conversion from int to Node.</p>
<p>Seen this before with: string s "Hello"; Implicit conversion through
single-arg ctor.</p>
<p>What’s the problem?</p>
<div class="sourceCode" id="cb77" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>Node n<span class="op">);</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="dv">4</span><span class="op">);</span> <span class="co">// works - 4 implicitly converted to Node.</span></span></code></pre></div>
<p>Danger</p>
<ul>
<li><p>Accidentally passing an int to a function expecting a
Node.</p></li>
<li><p>Silent conversion</p></li>
<li><p>Compiler does not signal an error</p></li>
<li><p>Potential errors not caught</p></li>
</ul>
<p>Don’t do things that limit the compiler’s ability to help you!
Disable the implicit conversion:</p>
<div class="sourceCode" id="cb78" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">,</span> </span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> Node<span class="op">(</span><span class="dt">int</span> data<span class="op">,</span> Node <span class="op">*</span>next<span class="op">=</span><span class="kw">nullptr</span><span class="op">):</span>data<span class="op">{</span>data<span class="op">},</span>next<span class="op">{</span>next<span class="op">}{}</span></span></code></pre></div>
<div class="sourceCode" id="cb79" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>Node n<span class="op">{</span><span class="dv">4</span><span class="op">};</span> <span class="co">// OK</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>Node n <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// X</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="dv">4</span><span class="op">);</span> <span class="co">// X</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>Node<span class="op">{</span><span class="dv">4</span><span class="op">});</span> <span class="co">// OK</span></span></code></pre></div>
<p><u>Destructors</u></p>
<p>When an object is destroyed (stack-allocated: goes out of scope,
heap-allocated: is deleted) a method called the destructor (dtor)
runs.</p>
<h1 class="unnumbered" id="lecture-8">Lecture 8</h1>
<p><u>Destructors</u></p>
<p>When an object is destroyed (stack-allocated: goes out of scope,
heap-allocated: is deleted),</p>
<p>Method called <u>destructor</u> runs (dtor).</p>
<p>Classes come with a dtor (just calls dtors for all fields that are
objects).</p>
<p>When an object is destroyed:</p>
<ol>
<li><p>Dtor body runs</p></li>
<li><p>Fields’ dtors are invoked in reverse delaration order (for fields
that are objects)</p></li>
<li><p>Space is deallocated</p></li>
</ol>
<p>When do we need to write a dtor?</p>
<div class="sourceCode" id="cb80" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>np <span class="op">=</span> <span class="kw">new</span> Node <span class="op">{</span><span class="dv">1</span><span class="op">,</span> newNode <span class="op">{</span><span class="dv">2</span><span class="op">,</span> newNode <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="kw">nullptr</span><span class="op">}}};</span></span></code></pre></div>
<p>If np goes out of scope</p>
<ul>
<li><p>The pointer (np) is reclaimed (stack-allocated).</p></li>
<li><p>The list is leaked</p></li>
</ul>
<p>If we say delete np; calls *np’s dtor, which doesn’t do anything.</p>
<p>np [] <span class="math inline">→</span> [1][-]<span
class="math inline">→</span>[2][-]<span
class="math inline">→</span>[3][/]</p>
<p>1 is freed, 2,3 are leaked</p>
<p>Write a dtor to ensure the whole list is freed:</p>
<div class="sourceCode" id="cb81" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Node<span class="op">(){</span><span class="kw">delete</span> next<span class="op">;}</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="co">// recursively calls next&#39;s dtor</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="co">// whole list is deallocated</span></span></code></pre></div>
<p>Now — delete np; frees the whole list</p>
<p>What happens when you reach the null pointer at the end of the
list?</p>
<p>Deleting a null pointer is guaranteed to be safe (and to do nothing).
The recursion stops.</p>
<p><u>Copy Assignment Operator</u></p>
<div class="sourceCode" id="cb82" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>Student s1 <span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">};</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>Student s2 <span class="op">=</span> s1<span class="op">;</span> <span class="co">// copy ctor</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>Student s3<span class="op">;</span> <span class="co">// default ctor</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>s3<span class="op">=</span>s1<span class="op">;</span> <span class="co">// copy, but not a construction</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="co">//^ copy assignment operator - uses compiler - supplied default</span></span></code></pre></div>
<p>May need to write your own.</p>
<div class="sourceCode" id="cb83" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Node <span class="op">&amp;</span>other<span class="op">){</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Node &amp; so that cascading works</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> other<span class="op">.</span>data<span class="op">;</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>        next <span class="op">=</span> other<span class="op">.</span>next <span class="op">?</span> newNode<span class="op">{*</span>other<span class="op">.</span>next<span class="op">}:</span><span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">// DANGEROUS</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Why?</p>
<div class="sourceCode" id="cb84" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>Node n <span class="op">{</span><span class="dv">1</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">2</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">3</span><span class="op">,</span><span class="kw">nullptr</span><span class="op">}}];</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span>n<span class="op">;</span> <span class="co">// deletes n.next and tries to copy n.next to n.next.</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="co">// UB</span></span></code></pre></div>
<p>When writing operator=, ALWAYS make sure it behaves well in the case
of self-assignment.</p>
<div class="sourceCode" id="cb85" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Node <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> other<span class="op">.</span>data<span class="op">;</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> next<span class="op">;</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>        next <span class="op">=</span> other<span class="op">.</span>next <span class="op">?</span> newNode<span class="op">{*</span>other<span class="op">.</span>next<span class="op">}</span> <span class="op">:</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Q: How big of a deal is self-assignment? How likely am I to write
<span class="math inline"><em>n</em> = <em>n</em></span>?</p>
<p>A: Not that likely. But consider <span
class="math inline"> * <em>p</em> =  * <em>q</em></span> if <span
class="math inline"><em>p</em> + <em>q</em></span> point at the same
location.</p>
<p>Or a[i] = a[j] if <span
class="math inline"><em>i</em> + <em>j</em></span> happen to be equal
(say, in a loop). Because of aliasing, it is a big deal!</p>
<p>Q: What’s wrong with if <span
class="math inline">(*<em>t</em><em>h</em><em>i</em><em>s</em>==<em>o</em><em>t</em><em>h</em><em>e</em><em>r</em>)</span>
as a check for self-assignment</p>
<p>A: Exercise</p>
<p>An even better implementation.</p>
<div class="sourceCode" id="cb86" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">&amp;</span>Node<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Node <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>tmp <span class="op">=</span> next<span class="op">;</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    next <span class="op">=</span> other<span class="op">.</span>next <span class="op">?</span> <span class="kw">new</span> Node<span class="op">{*</span>other<span class="op">.</span>next<span class="op">}</span> <span class="op">:</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> other<span class="op">.</span>data<span class="op">;</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> tmp<span class="op">;</span> </span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// if new fails, still have the old value of Node</span></span></code></pre></div>
<p><u>Alternative</u>: Copy + swap idiom</p>
<div class="sourceCode" id="cb87" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>utility<span class="op">&gt;;</span> </span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> swap<span class="op">(</span>Node <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>data<span class="op">,</span> other<span class="op">.</span>data<span class="op">);</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>next<span class="op">,</span> other<span class="op">.</span>next<span class="op">);</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Node <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>        Node tmp <span class="op">=</span> other<span class="op">;</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(</span>tmp<span class="op">)</span> <span class="co">// I am a deep copy of other, tmp is old me</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span> <span class="co">// tmp is stopped, dtor runs, destroys my old data</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>RValues &amp; RValue References</u></p>
<p><u>Recall:</u></p>
<ul>
<li><p>An lvalue is anything with an address</p></li>
<li><p>An l value reference (&amp;) is like a constant ptr with
auto-dereferencing. Always initialized to an lvalue</p></li>
</ul>
<p>Now consider:</p>
<div class="sourceCode" id="cb88" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>Node oddsOrEvens<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    Node odds <span class="op">{</span><span class="dv">1</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">3</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">5</span><span class="op">,</span><span class="kw">nullptr</span><span class="op">}}};</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    Null evens <span class="op">{</span><span class="dv">2</span><span class="op">,</span> newNode<span class="op">{</span><span class="dv">4</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">6</span><span class="op">,</span>newNode<span class="op">}}};</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> c<span class="op">;</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;0&#39;</span><span class="op">)</span> <span class="cf">return</span> evens<span class="op">;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">return</span> odds<span class="op">;</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    Node n <span class="op">=</span> oddsOrEvens<span class="op">();</span> <span class="co">// copy ctor:</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-9">Lecture 9</h1>
<p><u>RValues, RValue Refs</u></p>
<div class="sourceCode" id="cb89" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>Node oddsOrEvens<span class="op">()</span> <span class="op">{</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    Node odds <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="kw">new</span> Node<span class="op">{</span><span class="dv">3</span><span class="op">,</span>newNode<span class="op">{</span><span class="dv">5</span><span class="op">,</span><span class="kw">nullptr</span><span class="op">}}};</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    Node evens <span class="op">{</span><span class="dv">2</span><span class="op">,</span><span class="kw">new</span> Node <span class="op">{</span><span class="dv">4</span><span class="op">,</span> newNode <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="kw">nullptr</span><span class="op">}}};</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> c<span class="op">;</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c<span class="op">==</span><span class="ch">&#39;0&#39;</span><span class="op">)</span> <span class="cf">return</span> evens<span class="op">;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">return</span> odds<span class="op">;</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>Node n<span class="op">{</span>oddsorEvens<span class="op">()};</span> <span class="co">// copy ctor called #node times</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a><span class="co">// what is &quot;other&quot; here?</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a><span class="co">// reference to what?</span></span></code></pre></div>
<ul>
<li><p>Compiler creates <u>temporary object</u> to hold the result of
oddsorEvens</p></li>
<li><p>Other is a reference to this temporary</p>
<ul>
<li><p>Copy ctor deep-copies the data from this temporary</p></li>
</ul></li>
</ul>
<p><u>But</u></p>
<ul>
<li><p>The temporary is just going to be discarded anyway, as soon as
the start Node n <span>oddsOrEvens()</span>; is done.</p></li>
<li><p>Wasteful to have to copy from the temp</p>
<ul>
<li><p>Why not just steal it instead? — save the cost of a copy</p></li>
</ul></li>
<li><p>Need to be able to tell whether other is a reference to a
temporary object (where stealing would work) or a standalone object
(where we would have to copy).</p></li>
</ul>
<p>C++ - rvalue reference Node &amp;&amp; is a reference to a temporary
object (rvalue) of type Node.</p>
<p>Version of the ctor that takes a Node &amp;&amp;</p>
<div class="sourceCode" id="cb90" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span>Node <span class="op">&amp;&amp;</span>other<span class="op">):</span> <span class="co">// called move ctor</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>        data<span class="op">{</span>other<span class="op">.</span>data<span class="op">};</span> <span class="co">// steals other&#39;s data</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>        next<span class="op">{</span>other<span class="op">.</span>next<span class="op">}</span> <span class="op">{</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>            other<span class="op">.</span>next<span class="op">=</span><span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Similarly</u>:</p>
<div class="sourceCode" id="cb91" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>Node m<span class="op">;</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>m <span class="op">-</span> oddsOrEvens<span class="op">();</span> <span class="co">//assignmnent from temporary</span></span></code></pre></div>
<p>Move assignment operator:</p>
<div class="sourceCode" id="cb92" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">&amp;&amp;</span><span class="kw">operator</span><span class="op">=(</span>Node <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// steal other&#39;s data</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// destroy my old data</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Easy: swap without copy</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>data<span class="op">,</span> other<span class="op">.</span>data<span class="op">);</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>next<span class="op">,</span> other<span class="op">.</span>next<span class="op">);</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the temp will be destroyed &amp; take</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// my old data with it      </span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If you don’t define move operations, copying versions of them will be
used instead.</p>
<p><u>Copy/Move Elision</u></p>
<div class="sourceCode" id="cb93" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>vec makeAVec<span class="op">()</span> <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span> <span class="co">// invokes a basic Vec ctor</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>Vec v <span class="op">=</span> makeAVec<span class="op">();</span> <span class="co">// what runs? Move ctor? Copy ctor?</span></span></code></pre></div>
<p>Answer: Just the basic ctor. No copy ctor, no move ctor.</p>
<p>In some cases, the compiler is required to skip calling copy/move
ctors.</p>
<p>In this example, makeAVec writes its result (<span>0,0</span>)
directly into the space occupied by v in the caller, rather than copy it
later.</p>
<p><u>Eg</u></p>
<div class="sourceCode" id="cb94" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> doSomething<span class="op">(</span>Vec v<span class="op">);</span> <span class="co">// pass-by-value - copy/move ctor</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>doSomething<span class="op">(</span>makeAVec<span class="op">());</span> <span class="co">//result of makeAVec written directly into the param</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="co">// no copy or move</span></span></code></pre></div>
<p>This happens, even if dropping ctor calls would change the behaviour
of your program (e.g. if ctors print something).</p>
<p>You are not expected to know exactly when elision happens — just that
it does happen.</p>
<p>In summary: <u>Rule of 5</u> (<u>Big</u> 5)</p>
<p>If you need to write any one of</p>
<ol>
<li><p>copy ctor</p></li>
<li><p>copy assignment operator</p></li>
<li><p>dtor</p></li>
<li><p>make ctor</p></li>
<li><p>move assignment operator</p></li>
</ol>
<p>Then you usually need to write all 5.</p>
<p>But note that many classes don’t need any of these. The default
implementations are fine.</p>
<p>What characterizes classes that need the big 5, typically?
<u>ownership</u></p>
<ul>
<li><p>these classes are usually tasked with managing something (often
memory), but there are other things that need managing
(<u>resources</u>).</p></li>
</ul>
<p><u>Notice</u>:</p>
<p>Operator= is a member function. Previous operators we’ve written have
been standalone functions.</p>
<p>When an operator is declared as a member function, <u>this</u> plays
role of the first operand.</p>
<div class="sourceCode" id="cb95" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    Vec <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>x<span class="op">+</span>other<span class="op">.</span>x<span class="op">,</span> y<span class="op">+</span>other<span class="op">.</span>y<span class="op">};</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    Vec <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>x<span class="op">*</span>k<span class="op">,</span> y<span class="op">*</span>k<span class="op">};</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// implements 50% of the time</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// implements v * k</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>How do we implement <span class ="math inline"> k x v</span>? Can’t be a member function — first arg not a
Vec! Must be external:</p>
<div class="sourceCode" id="cb96" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">*</span>k<span class="op">;</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Advice</u>: If you overload arithmetic operators, overload the
assignment versions of these as well, and implement, e.g. <span
class="math inline">+</span> in terms of +=.</p>
<p><u>E.g</u></p>
<div class="sourceCode" id="cb97" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>Vec <span class="op">&amp;</span><span class="kw">operator</span><span class="op">+=</span> <span class="op">(</span>Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    v1<span class="op">.</span>x <span class="op">+=</span> v2<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    v1<span class="op">.</span>y <span class="op">+=</span> v2<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v1<span class="op">;</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>Vec <span class="op">&amp;</span><span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec <span class="op">&amp;</span>v1<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v2<span class="op">){</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    Vec temp<span class="op">{</span>v1<span class="op">};</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tmp <span class="op">+=</span> v2<span class="op">;</span> <span class="co">// uses += to implement +</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I/O Operators:</p>
<div class="sourceCode" id="cb98" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    ostream <span class="op">&amp;</span><span class="kw">operator</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>ostream <span class="op">&amp;</span>out<span class="op">){</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> out <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&gt;&gt;</span> y<span class="op">;</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>What’s wrong with this? Makes vec the first operand, not the
second.</p>
<p><span class="math inline">→</span> use as v <span
class="math inline">≪</span> cout | w <span class="math inline">≪</span>
(v <span class="math inline">≪</span> cout)</p>
<p>So define operator <span class="math inline">≪</span>,<span
class="math inline">≫</span> as standalone. Would have to put the stream
on the right</p>
<p>Certain operators must be members:</p>
<ul>
<li><p>operator=</p></li>
<li><p>operator[]</p></li>
<li><p>operator<span class="math inline">→</span></p></li>
<li><p>operator()</p></li>
<li><p>operator T (where T is a type)</p></li>
</ul>
<h1 class="unnumbered" id="lecture-10">Lecture 10</h1>
<div class="sourceCode" id="cb99" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    Vec <span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">):</span> x <span class="op">{</span>x<span class="op">},</span> y<span class="op">{</span>y<span class="op">}{}</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>Vec <span class="op">*</span>p <span class="op">=</span> <span class="kw">new</span> Vec<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>Vec moreVecs<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="co">// these want to call the default ctor on each item. </span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a><span class="co">// If no default ctor, can&#39;t initialize items (error)</span></span></code></pre></div>
<p>Options:</p>
<ol>
<li><p>Provide a default ctor</p>
<ol>
<li><p>This is not a good idea unless it makes sense for the class to
have a default ctor</p></li>
</ol></li>
<li><p>For stack arrays:</p>
<ol>
<li><p>Vec moreVecs[3] =
<span><span>0,0</span>,<span>1,1</span>,<span>2,4</span></span>;</p></li>
</ol></li>
<li><p>For heap arrays — create an array of pointers</p></li>
</ol>
<div class="sourceCode" id="cb100" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>Vec <span class="op">**</span>vp <span class="op">=</span> <span class="kw">new</span> Vec<span class="op">*[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>vp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> Vec<span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>vp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> Vec<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="op">..</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">:</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="kw">delete</span> vp<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> <span class="op">[]</span> vp<span class="op">;</span></span></code></pre></div>
<p><u>Const Objects</u></p>
<div class="sourceCode" id="cb101" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="at">const</span> Node <span class="op">&amp;</span>n<span class="op">){...}</span></span></code></pre></div>
<p>Const objects arise often, especially as parameters.</p>
<p>What is a const object?</p>
<ul>
<li><p>Fields cannot be mutated</p></li>
</ul>
<p>Can we call methods on a const obj?</p>
<p><u>Issue</u>: The method may modify fields, violate const.</p>
<p><u>A</u>: Yes — we can call methods that promise not to modify
fields.</p>
<p><u>Eg</u>:</p>
<div class="sourceCode" id="cb102" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> assns<span class="op">,</span> mt<span class="op">,</span> <span class="kw">final</span><span class="op">;</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grade<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// doesn&#39;t modify fields, so declare it const</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compiler checks that const methods don’t modify fields. Only const
methods can be called on const objects.</p>
<p>Now consider: want to collect usage stats on Student objs:</p>
<div class="sourceCode" id="cb103" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numMethodCalls <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grade<span class="op">()</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>numMethodCalls<span class="op">;</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ___<span class="op">;</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span> </span></code></pre></div>
<ul>
<li><p>Now can’t call grade on const students — it can’t be a const
method.</p></li>
<li><p>But mutating numMethodCalls affects only the physical constness
of student objects, not the logical constness.</p></li>
<li><p><u>Physical constness</u> — whether actual bits that make up the
object have changed at all.</p></li>
<li><p><u>Logical constness</u> — whether the object should be regarded
as different after the update.</p></li>
</ul>
<p>Want to be able to update numMethod calls, even if the object is
const:</p>
<div class="sourceCode" id="cb104" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">mutable</span> <span class="dt">int</span> numMethodCalls<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grade<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>numMethodCalls<span class="op">;</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ___<span class="op">;</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Mutable fields can be changed, even if the object is const. Use
mutable to indicate that the field does not contribute to the logical
constness of the object.</p>
<p><u>Static Fields &amp; Methods</u></p>
<p>numMethodCalls tracked the # of times a method was called on a
particular object. What if we want the # of times a method is called
over <u>all</u> student objects.</p>
<p><u>Eg</u>: What if we want to track how many students are
created?</p>
<p><u>Static members</u> associated with the class itself, not with any
specific instance (object).</p>
<div class="sourceCode" id="cb105" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> numInstances <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    Student<span class="op">(</span>___<span class="op">);</span> ____ <span class="op">{</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>numInstances<span class="op">;</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// only one, not one per student</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Static member functions — don’t depend on the specific instance (no
<u>this</u> parameter). Can only access static fields &amp; other static
functions.</p>
<div class="sourceCode" id="cb106" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> numInstances <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span> howMany<span class="op">()</span> <span class="op">{</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> numInstances <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>Student s1<span class="op">{</span><span class="dv">60</span><span class="op">,</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">},</span> s2<span class="op">{</span><span class="dv">70</span><span class="op">,</span><span class="dv">80</span><span class="op">,</span><span class="dv">90</span><span class="op">};</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>Student<span class="op">::</span>howMany<span class="op">();</span> <span class="co">// 2</span></span></code></pre></div>
<p><u>Comparing Objects</u></p>
<p>Recall: string comparison in C.</p>
<div class="sourceCode" id="cb107" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>strcmp<span class="op">(</span>s1<span class="op">,</span>s2<span class="op">)</span> <span class="op">=</span> </span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="co">// &lt; 0 if s1&lt;s2</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 0 if s1=s2</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="co">// &gt; 0 if s1&gt;s2</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="co">// done lexicographically</span></span></code></pre></div>
<p>Linear scan, char-by-char comparison.</p>
<p>Compare to string comparison in C++:</p>
<div class="sourceCode" id="cb108" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>s1<span class="op">&lt;</span>s2<span class="op">,</span> s1<span class="op">==</span>s2<span class="op">,</span> s1<span class="op">&gt;</span>s2<span class="op">,</span> etc<span class="op">.</span></span></code></pre></div>
<p>C++ version is easier to read. But one drawback.</p>
<p><u>Consider</u>:</p>
<div class="sourceCode" id="cb109" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>string s1 <span class="op">=</span> ___<span class="op">,</span> s2 <span class="op">=</span> _____<span class="op">;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>s1<span class="op">&lt;</span> s2<span class="op">)</span> <span class="op">{...}</span> <span class="co">// compare s1 &amp; s2</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>s1 <span class="op">==</span> s2<span class="op">)</span> <span class="op">{...}</span> <span class="co">// compare s1 &amp; s2 again</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{...}</span></span></code></pre></div>
<p>Two comparisons! Versus with strcmp</p>
<div class="sourceCode" id="cb110" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n <span class="op">=</span> strcmp<span class="op">(</span>s1<span class="op">,</span> s2<span class="op">);</span> <span class="co">// char *s1, *s2;</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{..}</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="co">// only one comparison</span></span></code></pre></div>
<p>Can we achieve the same using C++ strings, i.e have <u>one</u>
comparison that answers whether s1 &gt;, =, &lt; s2?</p>
<p>Introducing the 3-way comparison operator &lt;=&gt;</p>
<div class="sourceCode" id="cb111" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>compare<span class="op">&gt;;</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>string s1 <span class="op">=</span> ____<span class="op">,</span>s2<span class="op">=</span>____<span class="op">;</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>strong<span class="op">-</span>ordering result <span class="op">=</span> s1<span class="op">&lt;=&gt;</span>s2<span class="op">;</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="co">// makes one comparison</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>result <span class="op">&lt;</span><span class="dv">0</span><span class="op">)</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;less&quot;</span><span class="op">;</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>result <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;equal&quot;</span><span class="op">;</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;greater&quot;</span><span class="op">;</span></span></code></pre></div>
<p><u>Side note</u>:</p>
<div class="sourceCode" id="cb112" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co">//std::strong-ordering is a lot to type &amp; difficult to remember </span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="co">// shortcut</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result <span class="op">=</span> s1 <span class="op">&lt;=&gt;</span> s2<span class="op">;</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="co">// automatic type deduction</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> x <span class="op">=</span> expr<span class="op">;</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="co">// declares x to have a type meatching that of the value of expr.</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-11">Lecture 11</h1>
<p>Recall:</p>
<div class="sourceCode" id="cb113" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result <span class="op">=</span> s1 <span class="op">&lt;=&gt;</span> s2<span class="op">;</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 3-way comparison</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="co">// automatic type detection</span></span></code></pre></div>
<p>How can we support &lt;=&gt; in our own classes?</p>
<div class="sourceCode" id="cb114" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    auto† <span class="kw">operator</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span><span class="at">const</span> Vec <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> n <span class="op">=</span> x <span class="op">&lt;=&gt;</span> other<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>n<span class="op">==</span><span class="dv">0</span><span class="op">)?</span> y <span class="op">&lt;=&gt;</span> other<span class="op">.</span>y<span class="op">:</span> n<span class="op">;</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now we can say</p>
<div class="sourceCode" id="cb115" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>Vec v1<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},</span>v2<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">&lt;=&gt;</span> v2<span class="op">;</span></span></code></pre></div>
<p>But we can <u>also</u> say v1 &lt;= v2, etc. The 6 relational
operators &lt;, &lt;=, ==, !=, &gt;, &gt;= automatically rewritten in
terms of &lt;=&gt;.</p>
<p><u>Eg</u> v1 &lt;= v2 <span class="math inline">→</span> (v1
&lt;=&gt; v2) &lt;= 0</p>
<p>6 operators for free! But you can also sometimes get operator
&lt;=&gt; for free!</p>
<div class="sourceCode" id="cb116" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span><span class="at">const</span> Vec <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// does lexicographical ordering on fields of Vec.</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Equivalent to what we wrote before</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When might the default behaviour not be correct.</p>
<div class="sourceCode" id="cb117" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>Struct Node <span class="op">{</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lex order on these fields would compare ptr values - not useful</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Starship operator for Node</p>
<div class="sourceCode" id="cb118" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span><span class="at">const</span> Node <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Note: works for non-empty lists</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> n <span class="op">=</span> data <span class="op">&lt;=&gt;</span> other<span class="op">.</span>data<span class="op">;</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n<span class="op">!=</span><span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>next <span class="op">&amp;&amp;</span> <span class="op">!</span>other<span class="op">.</span>next<span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span> <span class="co">// n already equal</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>next<span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>strong<span class="op">.</span>ordering<span class="op">::</span>less<span class="op">;</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>other<span class="op">.</span>next<span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>strong<span class="op">.</span>ordering<span class="op">::</span>greater<span class="op">;</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span>next <span class="op">&lt;=&gt;</span> <span class="op">*</span>other<span class="op">.</span>next<span class="op">;</span>  </span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>Invariants &amp; Encapsulation</u></p>
<p>Consider:</p>
<div class="sourceCode" id="cb119" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Node<span class="op">()</span> <span class="op">{</span> <span class="kw">delete</span><span class="op">.</span>next<span class="op">;}</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>Node n <span class="op">{</span><span class="dv">2</span><span class="op">,</span><span class="kw">nullptr</span><span class="op">};</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>Node m <span class="op">{</span><span class="dv">3</span><span class="op">,&amp;</span>n<span class="op">};</span></span></code></pre></div>
<p>What happens when these go out of scope?</p>
<p>m’s dtor tries to delete n, but n is on the stack, not on the heap!
UB!</p>
<p>Class Node relies on an assumption for its proper operation: that
next is either nullptr or was allocated by new.</p>
<p>This is an example of an <u>invariant</u>. Statement that must hold
true, upon which Node relies.</p>
<p>We can’t guarantee this invariant — can’t trust the user to use Node
properly.</p>
<p><u>Eg</u> Stack — invariant — last item pushed is the first item
popped. But not if the client can rearrange the underlying data.</p>
<p>Hard to reason about programs if you can’t rely on invariants.</p>
<p>To enforce invariants, we introduce <u>encapsulation</u>.</p>
<ul>
<li><p>Want clients to treat objects as black boxes —
<u>capsules</u></p></li>
<li><p>Creates an abstraction — seal away details</p>
<ul>
<li><p>Only interact via provided methods</p></li>
</ul></li>
</ul>
<p><u>Eg</u></p>
<div class="sourceCode" id="cb120" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    Vec<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">);</span> <span class="co">// also public</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// default visibility is public</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>        Vec <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec <span class="op">&amp;</span>other<span class="op">);</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Private, can&#39;t be accessed outside of struct Vec</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Public, anyone can access </span></span></code></pre></div>
<p>In general: want private fields; only methods should be public.</p>
<p>Better to have default visibility = private.</p>
<p>Switch from struct to class.</p>
<div class="sourceCode" id="cb121" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vec <span class="op">{</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    Vec <span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">);</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    Vec <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec <span class="op">&amp;</span>other<span class="op">);</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Difference between struct &amp; class — default visibility. Struct is
public, class is private.</p>
<p>Let’s fix our linked list class.</p>
<p>list.cc</p>
<div class="sourceCode" id="cb122" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="co">// externally this is struct list::Node</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> <span class="kw">class</span> list <span class="op">{</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node<span class="op">;</span> <span class="co">//private nested class- only accessible within class list</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>theList <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addToFront<span class="op">(</span><span class="dt">int</span> n<span class="op">);</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>ith<span class="op">(</span><span class="dt">int</span> i<span class="op">);</span> <span class="co">// means we can do lst.ith(4) = 7;</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>List<span class="op">();</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>list-impl.cc</p>
<div class="sourceCode" id="cb123" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> list<span class="op">::</span>Node <span class="op">{</span> <span class="co">// nested class</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Node<span class="op">()</span> <span class="op">{</span><span class="kw">delete</span> next<span class="op">;}</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> List<span class="op">::</span>addToFront<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    theList <span class="op">=</span> <span class="kw">new</span> Node<span class="op">{</span>n<span class="op">,</span> theList<span class="op">};</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">&amp;</span>list<span class="op">::</span>ith<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>cur <span class="op">=</span> theList<span class="op">;</span></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> cur <span class="op">=</span> cur<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cur<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>List<span class="op">::~</span>List<span class="op">(){</span><span class="kw">delete</span> theList<span class="op">;}</span></span></code></pre></div>
<p>Only List can create/manipulate Node obs now.</p>
<p><span class="math inline">∴</span> can guarantee the invariant that
next is always either nullptr or allocated by new.</p>
<p><u>Iterator Pattern</u></p>
<ul>
<li><p>Now we can’t traverse node to node as we would a linked
list.</p></li>
<li><p>Repeatedly calling ith = <span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>
time</p></li>
<li><p>But we can’t expose the nodes or we lose encapsulation.</p></li>
</ul>
<p><u>SE Topic: Design Patterns</u></p>
<ul>
<li><p>Certain programming challenges arise often. Keep track of good
solutions. Reuse &amp; adapt them.</p></li>
</ul>
<p><u>Solution</u> — <u>Iterator Pattern</u></p>
<ul>
<li><p>Create a class that manages access to nodes</p></li>
<li><p>Will be an abstraction of a pointer — walk the list without
exposing nodes.</p></li>
</ul>
<p>Recall (c):</p>
<div class="sourceCode" id="cb124" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> arr<span class="op">;</span> p <span class="op">!=</span> arr<span class="op">+</span>size<span class="op">;</span> <span class="op">++</span>p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>    </span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb125" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node<span class="op">;</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>theList <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Iterator <span class="op">{</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>        Node <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>        Iterator<span class="op">(</span>Node <span class="op">*</span>p<span class="op">):</span>p<span class="op">{</span>p<span class="op">}{}</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>        Iterator <span class="op">&amp;</span><span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span> p <span class="op">=</span> p<span class="op">-&gt;</span>next<span class="op">;</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;}</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span> <span class="op">!=</span> <span class="op">(</span><span class="at">const</span> Iterator other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">!=</span> other<span class="op">.</span>p<span class="op">;}</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">&amp;</span><span class="kw">operator</span><span class="op">*()</span> <span class="op">{</span><span class="cf">return</span> p<span class="op">-&gt;</span>data<span class="op">;}</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>    Iterator begin<span class="op">()</span> <span class="op">{</span><span class="cf">return</span> Iterator<span class="op">{</span>theList<span class="op">};}</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>    Iterator end<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> Iterator<span class="op">{</span><span class="kw">nullptr</span><span class="op">};}</span></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-12">Lecture 12</h1>
<p>Recall: <u>Iterator Pattern</u></p>
<div class="sourceCode" id="cb126" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node<span class="op">;</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>theList <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Iterator <span class="op">{</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>        Node <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>        Iterator<span class="op">(</span>Node <span class="op">*</span>p<span class="op">):</span>p<span class="op">{</span>p<span class="op">}{}</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>        Iterator <span class="op">&amp;</span><span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span> p <span class="op">=</span> p<span class="op">-&gt;</span>next<span class="op">;</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;}</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span> <span class="op">!=</span> <span class="op">(</span><span class="at">const</span> Iterator other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">!=</span> other<span class="op">.</span>p<span class="op">;}</span></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">&amp;</span><span class="kw">operator</span><span class="op">*()</span> <span class="op">{</span><span class="cf">return</span> p<span class="op">-&gt;</span>data<span class="op">;}</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>    Iterator begin<span class="op">()</span> <span class="op">{</span><span class="cf">return</span> Iterator<span class="op">{</span>theList<span class="op">};}</span></span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>    Iterator end<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> Iterator<span class="op">{</span><span class="kw">nullptr</span><span class="op">};}</span></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Client code</p>
<div class="sourceCode" id="cb127" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>List l<span class="op">;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>addToFront<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>addToFront<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>addToFront<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>List<span class="op">::</span>Iterator it <span class="op">=</span> l<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> l<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="op">*</span>it <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="co">// can replace List::Iterator with auto</span></span></code></pre></div>
<p>This now runs in linear time, and we are not exposing the
pointers.</p>
<p><strong>Midterm Cutoff Here</strong></p>
<p><u>Shortcut:</u> range-based for loop</p>
<div class="sourceCode" id="cb128" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> n<span class="op">:</span>l<span class="op">)</span> <span class="op">{</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="co">// n stands for item in list here</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="co">// changes made on n here will not actually modify what is on the list</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a><span class="co">// n is a copy</span></span></code></pre></div>
<p>This is available for any class with</p>
<ul>
<li><p>methods begin &amp; end that produce iterators</p></li>
<li><p>the iterator must support <span class="math inline">!=</span>,
unary *, prefix++</p></li>
</ul>
<p>If you want to modify list items (or save copying):</p>
<div class="sourceCode" id="cb129" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>n<span class="op">:</span> l<span class="op">)</span> <span class="op">{</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>n<span class="op">;</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Encapsulation (continued)</u></p>
<p>List client can create iterators directly:</p>
<div class="sourceCode" id="cb130" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> List<span class="op">::</span>Iterator<span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="co">// functions as end operation but did not call end</span></span></code></pre></div>
<p>Violates encapsulation because the client should be using begin/end.
Don’t want client calling iterators directly.</p>
<p>We could — make Iterator’s constructor private <span
class="math inline">→</span> then client can’t call List::Iterator. But,
then neither can list.</p>
<p><u>Solution</u></p>
<p>Give List privileged access to Iterator. Make it a <u>friend</u>.</p>
<div class="sourceCode" id="cb131" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">class</span> Iterator <span class="op">{</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>            Node <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>            Iterator <span class="op">(</span>Node <span class="op">*</span>p<span class="op">);</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span><span class="op">:</span></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">...</span></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">...</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">friend</span> <span class="kw">class</span> List<span class="op">;</span></span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb131-12"><a href="#cb131-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb131-13"><a href="#cb131-13" aria-hidden="true" tabindex="-1"></a><span class="co">// List has access to ALL members of Iterator</span></span>
<span id="cb131-14"><a href="#cb131-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: does not matter where in class Iterator you put this</span></span></code></pre></div>
<p>Now List can still create Iterators, but client can only create
Iterators by calling begin/end.</p>
<p>Give your classes as few friends as possible — weakens
encapsulation.</p>
<p>Providing access to private fields. Accessor / mutator methods.</p>
<div class="sourceCode" id="cb132" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vec <span class="op">{</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getX<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">;}</span> <span class="co">//accessor</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setY<span class="op">(</span><span class="dt">int</span> z<span class="op">)</span> <span class="op">{</span> y <span class="op">=</span> z<span class="op">;}</span> <span class="co">// mutator</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Since we make setY, we can limit certain values </span></span></code></pre></div>
<p>What about operator<span class="math inline">≪</span></p>
<ul>
<li><p>needs x, y, but can’t be a member</p></li>
<li><p>if getX, getY defined — OK</p></li>
<li><p>if you don’t want to provide getX, getY — make operator <span
class="math inline">≪</span> a friend f’n.</p></li>
</ul>
<p>Friendship does not go both ways.</p>
<div class="sourceCode" id="cb133" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vec <span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> ostream <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&lt;&lt;(</span>ostream <span class="op">&amp;</span>out<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v<span class="op">);</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// non member function</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>ostream <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&lt;&lt;(</span>ostream <span class="op">&amp;</span>out<span class="op">,</span> <span class="at">const</span> Vec <span class="op">&amp;</span>v<span class="op">)</span> </span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out <span class="op">&lt;&lt;</span> v<span class="op">.</span>x <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&lt;&lt;</span> v<span class="op">.</span>y<span class="op">;</span>   </span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note: has access to Vec fields.</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Equality Revisited</u></p>
<p>Suppose we want to add a length() method to List: How should we
implement it?</p>
<p><u>Options</u>:</p>
<ol>
<li><p>Loop through the nodes &amp; count them. <span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></p></li>
<li><p>Store the length as a field &amp; keep it up to date. <span
class="math inline"><em>O</em>(1)</span> length with negligible
additional cost to addToFront.</p></li>
</ol>
<p>Option 2 is generally preferred.</p>
<p>But consider again the spaceship operator &lt;=&gt; in the special
case of equality checking:</p>
<p><span class="math inline"><em>l</em>1 =  = <em>l</em>2</span>
translates to <span
class="math inline">(<em>l</em>1&lt;=&gt;<em>l</em>2) =  = 0</span></p>
<p>What is the cost of &lt;=&gt; on 2 lists? O(length of shorter
list).</p>
<p>But for equality checking, we missed a shortcut: Lists whose lengths
are different <u>cannot</u> be equal.</p>
<p>In this case, we could answer "not equal" in <span
class="math inline"><em>O</em>(1)</span> time.</p>
<div class="sourceCode" id="cb134" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>theList<span class="op">;</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="at">const</span> List <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>theList <span class="op">&amp;&amp;</span> <span class="op">!</span>other<span class="op">.</span>theList<span class="op">){</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>strong<span class="op">-</span>ordering<span class="op">::</span>equal<span class="op">;</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>theList<span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>strong<span class="op">-</span>ordering<span class="op">::</span>less<span class="op">;</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>other<span class="op">.</span>theList<span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>strong<span class="op">-</span>ordering<span class="op">::</span>greater<span class="op">;</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// both non empty</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span>theList <span class="op">&lt;=&gt;</span> <span class="op">*</span>other<span class="op">.</span>theList<span class="op">;</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// comparing pointers so we need to dereference</span></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> List <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>length <span class="op">!=</span> other<span class="op">.</span>length<span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// O(1)</span></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span> <span class="op">&lt;=&gt;</span> other<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Operator &lt;=&gt; gives automatic impl’s to all 6 additional
operators, but if you write operator== separately, the compiler will use
that for both == and != instead of &lt;=&gt;. Lets you optimize your
equality checks, if possible.</p>
<p><u>System Modelling</u></p>
<p>Visualize the structure of the system (abstractions &amp;
relationships among them) to aid design, implementation,
communication.</p>
<p>Popular standard: UML (Unified Modelling Language)</p>
<p>Modelling class</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Name</th>
<th style="text-align: center;">Vec</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Fields (optional)</td>
<td style="text-align: center;">-x: Integer -y: Integer</td>
</tr>
<tr class="even">
<td style="text-align: right;">Methods (optional)</td>
<td style="text-align: center;">+getX: Integer +getY: Integer</td>
</tr>
</tbody>
</table>
</div>
<p>Access:</p>
<ul>
<li><p>- private</p></li>
<li><p>+ public</p></li>
</ul>
<p><u>Relationship: Composition of Classes</u></p>
<p>Recall:</p>
<div class="sourceCode" id="cb135" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Basis <span class="op">{</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    Vec v1<span class="op">,</span>v2<span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Embedding one object (Vec) inside another (Basis) is called
composition.</p>
<p>A basis is <u>composed</u> of 2 Vecs. They are <u>part of</u> a
Basis, and that is the only purpose of those Vecs.</p>
<p>Relationship: a Basis "owns a" Vec (in fact, it owns 2 of them).</p>
<p>If A "owns a" B, then <u>typically</u></p>
<ul>
<li><p>B has no identity outside A (no independent existence).</p></li>
<li><p>If A is destroyed, B is destroyed.</p></li>
<li><p>If A is copied, B is copied (deep copy)</p></li>
</ul>
<p><u>Eg</u> A car owns its engine — the engine is part of the car.</p>
<ul>
<li><p>Destroy the car <span class="math inline">→</span> destroy the
engine</p></li>
<li><p>copy the car <span class="math inline">→</span> copy the
engine</p></li>
</ul>
<p><u>Implementation</u>: <u>Usually</u> as composition of classes.</p>
<p><u>Modelling</u></p>
<p>A (diamond arrow) B A owns some # of B’s</p>
<p>Can annotate with multiplicities field names.</p>
<p><u>Aggregation</u></p>
<p>Compare car parts in a car ("owns a") vs. car parts in a catalogue.
The catalogue contains the parts, but the parts exist on their own.</p>
<p>"Has a" relationship (aggregation).</p>
<p>If A "has a" B, then <u>typically</u></p>
<ul>
<li><p>B exists apart from its association with A</p></li>
<li><p>If A is destroyed, B lives on</p></li>
<li><p>If A is copied, B is not (shallow copy) — copies of A share the
same B.</p></li>
</ul>
<h1 class="unnumbered" id="lecture-13">Lecture 13</h1>
<p><u>Recall</u>: Aggregation.</p>
<p><u>eg</u>: parts in a catalogue, ducks in a pond.</p>
<p>UML: [pond][diamond]<span class="math inline">→</span>
0...*[duck]</p>
<p>Typical Implementation: pointer fields</p>
<div class="sourceCode" id="cb136" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Pond <span class="op">{</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    Duck <span class="op">*</span>ducks<span class="op">[</span>MaxDucks<span class="op">];</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Case Study</u>: Does a pointer field always mean
non-ownership?</p>
<p>No! Let’s take a close look at lists &amp; nodes.</p>
<p>A Node owns the Nodes that follow it (Recall: implementation of Big 5
is a good sign of ownership).</p>
<p>But these ownerships are implemented with pointers.</p>
<p>Another view of Lists &amp; Nodes.</p>
<p>We could view the List object as owning all of the Nodes within
it.</p>
<p>What might this suggest about the implementation of Lists &amp; Nodes
in this case?</p>
<p>Likely — List is taking responsibility copying and
construction/destruction of all Nodes, rather than Node.</p>
<p>Possible iterative (i.e loop-based) management of pointers vs.
recursive routines when Nodes managed other Nodes.</p>
<p><u>Inheritance (Specialization)</u></p>
<p>Suppose you want to track a collection of Books.</p>
<div class="sourceCode" id="cb137" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    string title<span class="op">,</span> author<span class="op">;</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span> <span class="co">// pages</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">(</span>___<span class="op">);</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>For Textbooks — also a topic:</p>
<div class="sourceCode" id="cb138" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text <span class="op">{</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    string title<span class="op">,</span> author<span class="op">;</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    string topic<span class="op">;</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>    Text<span class="op">(</span>___<span class="op">);</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>For comic books, want the name of the hero:</p>
<p>This is OK — but doesn’t capture the relationships among Book, Text,
Comic.</p>
<p>And how do we create an array (or list) that contains a mixture of
these?</p>
<p><u>Could</u></p>
<ol>
<li><p>Use a union</p></li>
</ol>
<div class="sourceCode" id="cb139" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> BookTypes<span class="op">{</span>Book <span class="op">*</span>b<span class="op">;</span> Text <span class="op">*</span>t<span class="op">;</span> Comic <span class="op">*</span>c<span class="op">;};</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>BookTypes myBooks<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span></code></pre></div>
<ol start="2">
<li><p>Array of void * — pointer to anything</p></li>
</ol>
<p>Not good solutions — break the type system.</p>
<p><u>Rather, observe</u>: Texts and comics are <u>kind</u> of Books —
Books with extra features.</p>
<p>To model that in C++ — <u>inheritance</u></p>
<div class="sourceCode" id="cb140" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>    string title<span class="op">,</span> author<span class="op">;</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">(---);</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Base class (or super class)</span></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>    string topic<span class="op">;</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>    Text<span class="op">(---);</span></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Comic<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a>    string hero<span class="op">;</span></span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb140-20"><a href="#cb140-20" aria-hidden="true" tabindex="-1"></a>    Comic<span class="op">(---);</span></span>
<span id="cb140-21"><a href="#cb140-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb140-22"><a href="#cb140-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb140-23"><a href="#cb140-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-24"><a href="#cb140-24" aria-hidden="true" tabindex="-1"></a><span class="co">// Derived classes (or subclasses)</span></span></code></pre></div>
<p>Derived classes <u>inherit</u> fields &amp; methods from the base
class.</p>
<p>So Text, Comic, get title, author, length fields.</p>
<p>Any method that can be called on Book can be called on Text,
Comic.</p>
<p>Who can see these members?</p>
<p>title, author, length — private in Book — outsiders can’t see
them.</p>
<p>Can Text, Comic see them? <u>No</u> — even subclasses can’t see
them.</p>
<p>How do we initialize Text? Need title, author, length, topic. First
three initialize the Book part.</p>
<div class="sourceCode" id="cb141" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    Text<span class="op">(</span>string title<span class="op">,</span> string author<span class="op">,</span> <span class="dt">int</span> length<span class="op">,</span> string topic<span class="op">):</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    title<span class="op">{</span>title<span class="op">},</span>author<span class="op">{</span>author<span class="op">},</span>length<span class="op">{</span>length<span class="op">},</span>topic<span class="op">{</span>topic<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Does not compile</span></span></code></pre></div>
<p>Wrong for two reasons.</p>
<ol>
<li><p>Title, etc. are not accessible in Text (and even if they were,
the MIL only lets you mention your own fields).</p></li>
<li><p>Once again, when an object is created:</p>
<ol>
<li><p>Space is allocated</p></li>
<li><p>Superclass part is constructed <mark>*new*</mark></p></li>
<li><p>Fields are constructed in declaration order</p></li>
<li><p>Constructor body runs</p></li>
</ol></li>
</ol>
<p>So a constructor for Book must run before the fields of Text can be
initialized. If Book has no default constructor, a constructor for Book
must be invoked explicitly.</p>
<div class="sourceCode" id="cb142" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>    Text<span class="op">(</span>string title<span class="op">,</span> string author<span class="op">,</span> <span class="dt">int</span> length<span class="op">,</span> string topic<span class="op">):</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">{</span>title<span class="op">,</span>author<span class="op">,</span>length<span class="op">},</span>topic<span class="op">{</span>topic<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// step 2                 step 3       step 4</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a><span class="co">// this is how to intialize when don&#39;t have access</span></span></code></pre></div>
<p>Good reasons to keep superclass fields inaccessible to
subclasses.</p>
<p>If you want to give subclasses access to certain members:
<u>protected</u> access:</p>
<div class="sourceCode" id="cb143" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>        string title<span class="op">,</span>author<span class="op">;</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//accessible to Book and its subclasses</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// but no one else</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>        Book<span class="op">(---);</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb143-15"><a href="#cb143-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb143-16"><a href="#cb143-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> addAuthor<span class="op">(</span>string newAuthor<span class="op">)</span> <span class="op">{</span></span>
<span id="cb143-17"><a href="#cb143-17" aria-hidden="true" tabindex="-1"></a>            author <span class="op">+=</span> newAuthor<span class="op">;</span></span>
<span id="cb143-18"><a href="#cb143-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// OK </span></span>
<span id="cb143-19"><a href="#cb143-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb143-20"><a href="#cb143-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Not a good idea to give subclasses unlimited access to fields.</p>
<p><u>Better</u>: keep fields private, provide protected
accessors/mutators</p>
<div class="sourceCode" id="cb144" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    string title<span class="op">,</span> author<span class="op">;</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span> <span class="co">// pages</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    string getTitle<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setAuthor<span class="op">(</span>string newAuthor<span class="op">);</span></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// subclasses can call these</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">(---);</span></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isHeavy<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Relationship among Text, Comic, Book — called "is—a"</p>
<ul>
<li><p>A Text is a Book</p></li>
<li><p>A Comic is a Book</p></li>
</ul>
<p>Now consider the method isHeavy — when is a Book heavy?</p>
<ul>
<li><p>for ordinary books — &gt; 200 pages</p></li>
<li><p>for Texts — &gt; 500 pages</p></li>
<li><p>for Comics — &gt; 30 pages</p></li>
</ul>
<div class="sourceCode" id="cb145" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> isHeavy<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> length <span class="op">&gt;</span> <span class="dv">200</span><span class="op">;}</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Comic<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>        book isHeavy<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">&gt;</span> <span class="dv">30</span><span class="op">;}</span></span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a>etc<span class="op">.</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-14">Lecture 14</h1>
<p><u>Recall</u>: isHeavy</p>
<p>bool isHeavy() const:</p>
<ul>
<li><p>for Books: &gt; 200 pages</p></li>
<li><p>for Texts: &gt; 500 pages</p></li>
<li><p>for Comics &gt; 30 pages</p></li>
</ul>
<div class="sourceCode" id="cb146" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>Book b <span class="op">{</span><span class="st">&quot;A small book&quot;</span><span class="op">,</span> ___<span class="op">,</span> <span class="dv">50</span><span class="op">};</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>Comic c<span class="op">{</span><span class="st">&quot;A big comic&quot;</span><span class="op">,</span> ___<span class="op">,</span> <span class="dv">40</span><span class="op">,</span> <span class="st">&quot;Hero&quot;</span><span class="op">};</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> b<span class="op">.</span>isHeavy<span class="op">();</span> <span class="co">// false</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> c<span class="op">.</span>isHeavy<span class="op">();</span> <span class="co">// true</span></span></code></pre></div>
<p>Now since public inheritance means "is a", we can do this.</p>
<div class="sourceCode" id="cb147" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>Book b <span class="op">=</span> Comic<span class="op">{</span><span class="st">&quot;A big comic&quot;</span><span class="op">,</span>___<span class="op">,</span><span class="dv">40</span><span class="op">,</span>___<span class="op">};</span></span></code></pre></div>
<p><u>Q</u>: Is b heavy <span class="math inline">⇔</span> I.e.
b.isHeavy() — true or false? <span class="math inline">⇔</span> Which
isHeavy runs? Book::isHeavy or Comic::isHeavy?</p>
<p><u>A</u>: <u>No</u> b is not heavy, Book::isHeavy runs.</p>
<p>Why? Book b [title, author, length space on stack] = Comic [title,
author, length, hero]. Tries to fit a comic object where there is only
space for a Book object. What happens? Comic is <u>sliced</u> —
<strong>hero field chopped off</strong>.</p>
<ul>
<li><p>Comic coerced into a Book</p></li>
</ul>
<p>So Book b = Comic{...}; creates a Book and Book::isHeavy runs.</p>
<p><u>Note</u>: slicing takes place even if the two object types are the
same size. Having the behaviour of isHeavy depend on whether Book &amp;
Comic have the same size would not be good.</p>
<p>When accessing objects through pointers, slicing is unnecessary and
doesn’t happen:</p>
<div class="sourceCode" id="cb148" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>Comic <span class="op">{</span>___<span class="op">,</span>___<span class="op">,</span><span class="dv">40</span><span class="op">,</span>___<span class="op">};</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>pb <span class="op">=</span> <span class="op">&amp;</span>c <span class="co">// wont slice</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>c<span class="op">.</span>isHeavy<span class="op">();</span> <span class="co">// true</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>pb<span class="op">-&gt;</span>isHeavy<span class="op">();</span> <span class="co">// still False!</span></span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ... and still Book::isHeavy runs when we access pb-&gt;isHeavy()</span></span></code></pre></div>
<p>Compiler uses the type of the pointer (or ref) to decide which
isHeavy to run — does not consider the actual type of the object (uses
the declared type).</p>
<p>Behaviour of the object depends on what type of pointer or reference
you access it through.</p>
<p>How can we make Comic act like a Comic, even when pointed to by a
Book pointer, i.e. How can ewe get Comic::isHeavy to run?</p>
<p>Declare the method <u>virtual</u>.</p>
<div class="sourceCode" id="cb149" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">bool</span> isHeavy<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> length <span class="op">&gt;</span> <span class="dv">200</span><span class="op">;}</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Comic<span class="op">:</span><span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isHeavy<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span><span class="cf">return</span> length <span class="op">&gt;</span><span class="dv">30</span><span class="op">;}</span></span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// override = make sure that this overrides the virtual</span></span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb150" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>Comic c <span class="op">{</span>__<span class="op">,</span>__<span class="op">,</span><span class="dv">40</span><span class="op">,</span>__<span class="op">};</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>Comic <span class="op">*</span>pc <span class="op">=</span> <span class="op">&amp;</span>c<span class="op">;</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>pb <span class="op">=</span> <span class="op">&amp;</span>c<span class="op">;</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>Book <span class="op">&amp;</span>rb <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>pc<span class="op">-&gt;</span>isHeavy<span class="op">();</span> <span class="co">// true</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>pb<span class="op">-&gt;</span>isHeavy<span class="op">();</span> <span class="co">// true</span></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>rb<span class="op">.</span>isHeavy<span class="op">();</span> <span class="co">// true</span></span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a><span class="co">//Comic::isHeavy runs in all 3 cases</span></span></code></pre></div>
<p>Virtual methods — choose which class’ method to run based on the
actual type of the object at run time.</p>
<p><u>E.g.</u> My book collection</p>
<div class="sourceCode" id="cb151" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>myBooks<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> myBooks<span class="op">[</span>i<span class="op">]-&gt;</span>isHeavy<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a><span class="co">// isHeavy() above uses Book::isHeavy for Books</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a><span class="co">//                      Text::isHeavy for Texts</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a><span class="co">//                      Comic::isHeavy for Comics</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a><span class="co">// automatically </span></span></code></pre></div>
<p>Accommodating multiple types under one abstraction:
<u>polymorphism</u>. ("many forms").</p>
<p>Note: this is why a function void f(istream) can be passed an
ifstream — ifstream is a subclass of istream.</p>
<p><mark>Danger!</mark>: What if we had written Book myBooks[20], and
tried to use that polymorphically.</p>
<p>Consider:</p>
<div class="sourceCode" id="cb152" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>Book books<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>    books<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> Book<span class="op">{</span><span class="st">&quot;book&quot;</span><span class="op">,</span> <span class="st">&quot;book author&quot;</span><span class="op">,</span> ___<span class="op">};</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>Comic c<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="st">&quot;comic 1&quot;</span><span class="op">,</span> <span class="st">&quot;artist 1&quot;</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="st">&quot;hero1&quot;</span><span class="op">},</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span><span class="st">&quot;comic 2&quot;</span><span class="op">,</span> <span class="st">&quot;artist 2&quot;</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="st">&quot;hero2</span><span class="sc">}}</span><span class="st">;</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>c<span class="op">);</span> <span class="co">// legal - a Comic * is a Book*</span></span></code></pre></div>
<p>What might c be now? (UB).</p>
<div class="sourceCode" id="cb153" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="op">{{</span><span class="st">&quot;comic 1&quot;</span><span class="op">,</span> <span class="st">&quot;artist 1&quot;</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="st">&quot;book&quot;</span><span class="op">},</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="st">&quot;book author&quot;</span><span class="op">,</span> <span class="op">???,...}};</span></span></code></pre></div>
<p><u>Never</u> use arrays of objects polymorphically. Use array of
pointers.</p>
<p><u>Destructor Revisited</u></p>
<div class="sourceCode" id="cb154" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    X<span class="op">(</span><span class="dt">int</span> n<span class="op">):</span> x<span class="op">{</span><span class="kw">new</span> <span class="dt">int</span> <span class="op">[</span>n<span class="op">]}</span> <span class="op">{}</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>X<span class="op">{}</span> <span class="op">{</span><span class="kw">delete</span><span class="op">[]</span> x<span class="op">;}</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>Class Y<span class="op">:</span> <span class="kw">public</span> X<span class="op">{</span></span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> m<span class="op">):</span> X<span class="op">{</span>n<span class="op">},</span> y<span class="op">{</span><span class="kw">new</span> <span class="dt">int</span> <span class="op">[</span>m<span class="op">]}</span> <span class="op">{}</span></span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Y<span class="op">()</span> <span class="op">{</span><span class="kw">delete</span> <span class="op">[]</span> y<span class="op">;}</span></span>
<span id="cb154-13"><a href="#cb154-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Is it wrong that Y doesn’t delete x?</p>
<p>No, not wrong:</p>
<ol>
<li><p>x is private. Can’t do it anyway</p></li>
<li><p>When an object is destroyed:</p>
<ol>
<li><p>Destructor body runs</p></li>
<li><p>Fields are destructed in reverse declaration order</p></li>
<li><p>Superclass part is destructed (Ỹ implicitly calls X̃)</p></li>
<li><p>Space is deallocated</p></li>
</ol></li>
</ol>
<div class="sourceCode" id="cb155" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">*</span>myX <span class="op">=</span> <span class="kw">new</span> Y<span class="op">{</span><span class="dv">10</span><span class="op">,</span><span class="dv">20</span><span class="op">};</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> myX<span class="op">;</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="co">// leaks! Why? -calls ~X but not ~Y</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="co">// only x, but not y, is freed.</span></span></code></pre></div>
<p>How can we ensure that deletion through a pointer to the superclass
will call the subclass destructor? Make the destructor
<u>virtual</u>!</p>
<div class="sourceCode" id="cb156" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>    virutal <span class="op">~</span>X<span class="op">()</span> <span class="op">{</span><span class="kw">delete</span> <span class="op">[]</span>x<span class="op">;}</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><mark>ALWAYS</mark> — make the destructor virtual in classes that are
meant to have subclasses. Even if the virtual destructor doesn’t do
anything.</p>
<p>If a class is <u>not</u> meant to have subclasses, declare it
<u>final</u>.</p>
<div class="sourceCode" id="cb157" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y <span class="kw">final</span><span class="op">:</span><span class="kw">public</span> X<span class="op">{...};</span></span></code></pre></div>
<p><u>Pure Virtual Methods &amp; Abstract Classes</u></p>
<div class="sourceCode" id="cb158" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Student <span class="op">{</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">int</span> fees<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>2 kinds of student: regular &amp; co-op.</p>
<div class="sourceCode" id="cb159" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> regular<span class="op">:</span><span class="kw">public</span> Student <span class="op">{</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> fees<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// computes students&#39; fees</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CoOp<span class="op">:</span> <span class="kw">public</span> Student<span class="op">{</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> fees<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// computes students&#39; fees</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>What should we put for Student::fees?</p>
<p>Not sure — every student should be regular or co-op.</p>
<p>Can explicitly give Student::fees <u>no</u> implementation.</p>
<div class="sourceCode" id="cb160" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Student <span class="op">{</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">int</span> fees<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// method has no (*) implementation</span></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// called a pure virtual method</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// subclass must override this because we don&#39;t have impl</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>A class with a pure virtual method cannot be instantiated.</p>
<p>Student s; (will not compile) (needs to be either regular or
co-op).</p>
<p>Called an <u>abstract class</u>. Its purpose is to organize
subclasses.</p>
<h1 class="unnumbered" id="lecture-15">Lecture 15</h1>
<p>Abstract class</p>
<div class="sourceCode" id="cb161" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Student <span class="op">{</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">int</span> fees<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// pure virtual method</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>student s<span class="op">;</span> <span class="co">// cannot be instantiated</span></span></code></pre></div>
<p>Subclasses of an abstract class are also abstract, unless they
implement all pure virtual methods.</p>
<p>Non-abstract classes are called <u>concrete</u>.</p>
<div class="sourceCode" id="cb162" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Regular<span class="op">:</span> <span class="kw">public</span> Student <span class="op">{</span> <span class="co">// concrete</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> fees<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{...}</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>UML</u>:</p>
<ul>
<li><p>virtual/pure virtual methods — italics</p></li>
<li><p>abstract classes — class name in italics</p></li>
<li><p># protected : <u>static</u></p></li>
</ul>
<p><u>Inheritance and Copy/Move</u></p>
<div class="sourceCode" id="cb163" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// defines Big 5</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text<span class="op">:</span> <span class="kw">public</span> Book <span class="op">{</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>    string topic<span class="op">;</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// does not define the big 5</span></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true" tabindex="-1"></a>Text t <span class="op">{</span><span class="st">&quot;Algorithms&quot;</span><span class="op">,</span><span class="st">&quot;CLRS&quot;</span><span class="op">,</span><span class="dv">500000</span><span class="op">,</span><span class="st">&quot;cs&quot;</span><span class="op">};</span></span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true" tabindex="-1"></a>Text t2 <span class="op">=</span> t<span class="op">;</span> <span class="co">// No copy ctor in Text - what happens?</span></span></code></pre></div>
<ul>
<li><p>It calls Book’s copy ctor</p></li>
<li><p>Then goes field-by-field (i.e default behaviour) for the Text
part</p></li>
<li><p>Same for the other operations</p></li>
</ul>
<p>To write your own operations:</p>
<div class="sourceCode" id="cb164" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="co">//copy constructor</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>Text<span class="op">::</span>Text<span class="op">(</span><span class="at">const</span> Text <span class="op">&amp;</span>other<span class="op">):</span> Book<span class="op">{</span>other<span class="op">},</span>topic<span class="op">{</span>other<span class="op">.</span>topic<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="co">// copy assignment operator</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>Text <span class="op">&amp;</span>Text<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Text <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span>other<span class="op">);</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// then assign topic yourself (the field belonging to text)</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    topic <span class="op">=</span> other<span class="op">.</span>topic<span class="op">;</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a><span class="co">// move constructor (WRONG)</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>Text<span class="op">::</span>Text<span class="op">(</span>Text <span class="op">&amp;&amp;</span>other<span class="op">):</span> Book<span class="op">{</span>other<span class="op">},</span> topic<span class="op">{</span>other<span class="op">.</span>topic<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a><span class="co">// other is an lvalue </span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a><span class="co">// these are both copy constructors, not move constructors</span></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a><span class="co">// won&#39;t work</span></span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a>Text<span class="op">::</span>Text<span class="op">(</span>Text <span class="op">&amp;&amp;</span>other<span class="op">):</span> Book <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>other<span class="op">)},</span> topic<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>other<span class="op">.</span>topic<span class="op">)}</span> <span class="op">{}</span></span>
<span id="cb164-20"><a href="#cb164-20" aria-hidden="true" tabindex="-1"></a><span class="co">// std::move is a function that treats an lvalue as an rvalue</span></span>
<span id="cb164-21"><a href="#cb164-21" aria-hidden="true" tabindex="-1"></a><span class="co">// now acts as move instead of copy</span></span>
<span id="cb164-22"><a href="#cb164-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-23"><a href="#cb164-23" aria-hidden="true" tabindex="-1"></a>Text <span class="op">&amp;</span>Text<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span>Text <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb164-24"><a href="#cb164-24" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="bu">std::</span>move<span class="op">(</span>other<span class="op">));</span></span>
<span id="cb164-25"><a href="#cb164-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// topic = other.topic would be a copy</span></span>
<span id="cb164-26"><a href="#cb164-26" aria-hidden="true" tabindex="-1"></a>    topic <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>topic<span class="op">.</span>other<span class="op">);</span></span>
<span id="cb164-27"><a href="#cb164-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// strings move assignment operator</span></span>
<span id="cb164-28"><a href="#cb164-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb164-29"><a href="#cb164-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note: even though ‘other’ points at an rvalue, other itself is an
lvalue (so is other.topic).</p>
<p>std::move<span class="math inline">(<em>x</em>)</span> forces an
lvalue x to be treated as an rvalue, so that the "move" versions of the
operations run.</p>
<p>Operations above are equivalent to the default — specialize as needed
for Nodes, etc.</p>
<p>Now consider:</p>
<div class="sourceCode" id="cb165" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>Text t1<span class="op">{,,,},</span> t2<span class="op">{,,,};</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>pb1 <span class="op">=</span> <span class="op">&amp;</span>t1<span class="op">,</span> <span class="op">*</span>pb2 <span class="op">=</span> <span class="op">&amp;</span>t2<span class="op">;</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a><span class="co">// What if we do *pb1 = *pb2?</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Book::operator= runs</span></span></code></pre></div>
<p><u>Partial assignment</u> — copies only the Book part.</p>
<p>How can we prevent this? Try making operator= virtual.</p>
<div class="sourceCode" id="cb166" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> Book <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Book <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Text <span class="op">{</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>        Text <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Book <span class="op">&amp;</span>other<span class="op">)</span> <span class="kw">override</span> <span class="op">{...}</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// not Text &amp;operator=(const Text &amp;other) override {.}</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Note</u>: Different return types are fine, but <u>parameter</u>
types must be the same, or it’s not an override (and won’t compile).
Violates "is a" if they don’t match.</p>
<p>Assignment of a Book object into a Text object would compile:</p>
<div class="sourceCode" id="cb167" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>Text t<span class="op">{...};</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> Book<span class="op">{...};</span> </span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="co">// using a Book to assign a Text</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a><span class="co">// BAD (but it compiles)</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a><span class="co">//Also </span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> Comic<span class="op">{...};</span> <span class="op">--</span> REALLY BAD</span></code></pre></div>
<p>If operator= is non-virtual — partial assignment through base class
pointers.</p>
<p>If virtual — allows mixed assignment — also <strong>bad</strong>.</p>
<p><u>Recommendation</u>: all superclasses should be
<u>abstract</u>.</p>
<p>Rewrite Book hierarchy</p>
<div class="sourceCode" id="cb168" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AbstractBook <span class="op">{</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>    string title<span class="op">,</span> author<span class="op">;</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    AbstractBook <span class="op">&amp;</span><span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> AbstractBook <span class="op">&amp;</span>other<span class="op">);</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prevents assignment through base class ptrs from compiling,</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// but implementation still available for subclasses.</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>    AbstractBook<span class="op">(---);</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>AbstractBook<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Need at least one pure virtual method If you don&#39;t have one,</span></span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use the destructor (to make the class abstract).</span></span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb169" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NormalBook<span class="op">:</span><span class="kw">public</span> AbstractBook <span class="op">{</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    Normal Book <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> NormalBook <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>        AbstractBook<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span>other<span class="op">);</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Other classes — similar. Prevents partial &amp; mixed assignment.</p>
<p>Note: virtual dtor <u>MUST</u> be implemented, even though it is pure
virtual.</p>
<div class="sourceCode" id="cb170" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>Abstract Book<span class="op">::~</span>AbstractBook<span class="op">()</span> <span class="op">{}</span></span></code></pre></div>
<p>Because subclass destructors <u>WILL</u> call it as part of Step
3.</p>
<p><u>Templates</u></p>
<p>Huge topic — just the highlights</p>
<div class="sourceCode" id="cb171" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>        Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>What if you want to store something else? Whole new class?</p>
<p><u>OR</u> a <u>template</u> — class parameterized by a type.</p>
<div class="sourceCode" id="cb172" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">class</span> Stack <span class="op">{</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size<span class="op">,</span>cap<span class="op">;</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span>contents<span class="op">;</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> push<span class="op">(</span>T x<span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>    T top<span class="op">()</span> <span class="op">{...}</span></span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> pop<span class="op">()</span> <span class="op">{...}</span></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>        T data<span class="op">;</span></span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a>        Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb172-16"><a href="#cb172-16" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>theList<span class="op">;</span></span>
<span id="cb172-17"><a href="#cb172-17" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb172-18"><a href="#cb172-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Iterator <span class="op">{</span></span>
<span id="cb172-19"><a href="#cb172-19" aria-hidden="true" tabindex="-1"></a>        Node <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb172-20"><a href="#cb172-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb172-21"><a href="#cb172-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb172-22"><a href="#cb172-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb172-23"><a href="#cb172-23" aria-hidden="true" tabindex="-1"></a>        T<span class="op">&amp;</span><span class="kw">operator</span><span class="op">*(){...};</span></span>
<span id="cb172-24"><a href="#cb172-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb172-25"><a href="#cb172-25" aria-hidden="true" tabindex="-1"></a>    T <span class="op">&amp;</span>ith<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{...}</span></span>
<span id="cb172-26"><a href="#cb172-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addToFront<span class="op">(</span>T n<span class="op">);</span></span>
<span id="cb172-27"><a href="#cb172-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-16">Lecture 16</h1>
<p><u>Recall</u>:</p>
<div class="sourceCode" id="cb173" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>        T data<span class="op">;</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>        Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">....</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>client</u></p>
<div class="sourceCode" id="cb174" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>List <span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> l1<span class="op">;</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Can also do</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>List <span class="op">&lt;</span>List<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> l2<span class="op">;</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>l1<span class="op">.</span>addtoFront<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>l2<span class="op">.</span>addtoFront<span class="op">(</span>l1<span class="op">);</span></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>List<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator it <span class="op">=</span> l1<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> l1<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="op">*</span>it <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>or indeed</p>
<div class="sourceCode" id="cb175" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> n<span class="op">:</span> l1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compiler specializes templates at the source code level, and then
compiles the specializations.</p>
<p><u>The Standard Template Library (STL)</u></p>
<p>Large # of useful templates</p>
<p><u>Eg</u> dynamic-length arrays: <u>vectors</u></p>
<div class="sourceCode" id="cb176" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>vector<span class="op">&gt;;</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span> <span class="co">// 4 5</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>emplace_back<span class="op">(</span><span class="dv">6</span><span class="op">);</span> <span class="co">// 4 5 6</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>emplace_back<span class="op">(</span><span class="dv">7</span><span class="op">);</span> <span class="co">// 4 5 6 7</span></span></code></pre></div>
<p>But also:</p>
<div class="sourceCode" id="cb177" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector w<span class="op">{</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">};</span> <span class="co">// Note: no int</span></span></code></pre></div>
<p>If the type argument of a template can be deduced from its
initialization, you can leave it out. &lt;int&gt; is deduced here.</p>
<p>To get an array of 4 5’s, we need to use round brackets.</p>
<div class="sourceCode" id="cb178" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>vector <span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">(</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">);</span> <span class="co">// 5 5 5 5</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>vector <span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span> <span class="co">// 4 5</span></span></code></pre></div>
<p><u>Looping over vectors</u></p>
<div class="sourceCode" id="cb179" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> v<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a><span class="co">//or </span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>vec<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator it <span class="op">=</span> v<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> v<span class="op">.</span>end<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> v<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a><span class="co">// vec&lt;int&gt;::iterator is auto</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> n <span class="op">:</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a><span class="co">// To iterate in reverse:</span></span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-15"><a href="#cb179-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>reverse_iterator it <span class="op">=</span> v<span class="op">.</span>rbegin<span class="op">();</span> it <span class="op">!=</span> v<span class="op">.</span>rend<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb179-16"><a href="#cb179-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb179-17"><a href="#cb179-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb179-18"><a href="#cb179-18" aria-hidden="true" tabindex="-1"></a><span class="co">// vector&lt;int&gt;::reverse_iterator is auto</span></span>
<span id="cb179-19"><a href="#cb179-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-20"><a href="#cb179-20" aria-hidden="true" tabindex="-1"></a><span class="co">// Cannot use range based loop because implicitly calls normal begins</span></span>
<span id="cb179-21"><a href="#cb179-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-22"><a href="#cb179-22" aria-hidden="true" tabindex="-1"></a><span class="co">// rbegin points to last item (!= end)</span></span>
<span id="cb179-23"><a href="#cb179-23" aria-hidden="true" tabindex="-1"></a><span class="co">// rend points before the first item (!= begin)</span></span></code></pre></div>
<div class="sourceCode" id="cb180" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>pop<span class="op">-</span>back<span class="op">()</span> <span class="op">---</span> remove last element</span></code></pre></div>
<p>Use iterators to remove items from inside a vector: <u>Ex:</u> Remove
all 5’s from the vector v.</p>
<p><u>Attempt #1</u>:</p>
<div class="sourceCode" id="cb181" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> v<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> v<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>it <span class="op">==</span> <span class="dv">5</span><span class="op">)</span> v<span class="op">.</span>erase<span class="op">(</span>it<span class="op">);</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Why is this wrong? Consider</p>
<div class="sourceCode" id="cb182" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="co">// vector of 1,5,5,2</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>erase<span class="op">(</span>it<span class="op">)</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="co">// it is still pointing to second slot, and now second 5 is in that slot</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a><span class="co">// incrementing to the next (++it)</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a><span class="co">// missed the second 5</span></span></code></pre></div>
<p><u>Note</u>: After erase, it points at a different item. The rule is:
after an insertion or erase, all iterators pointing after the point of
insertion/erasure are considered invalid and must be refreshed.</p>
<p><u>Correct:</u></p>
<div class="sourceCode" id="cb183" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> v<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> v<span class="op">.</span>end<span class="op">();)</span> <span class="op">{</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>it <span class="op">==</span> <span class="dv">5</span><span class="op">)</span> it <span class="op">=</span> v<span class="op">.</span>erase<span class="op">(</span>it<span class="op">);</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// returns iterator to the point of erasure</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">++</span>it<span class="op">;</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><u>Design Patterns Continued</u></p>
<p>Guiding principle: program to the interface, not the
implementation.</p>
<ul>
<li><p>Abstract base classes define the interface</p>
<ul>
<li><p>work with base class pointers &amp; call their methods</p></li>
</ul></li>
<li><p>Concrete subclasses can be swapped in &amp; out</p>
<ul>
<li><p>abstraction over a variety of behaviours</p></li>
</ul></li>
</ul>
<p><u>Eg</u> Iterator pattern.</p>
<div class="sourceCode" id="cb184" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">class</span> Iterator<span class="op">:</span> <span class="kw">public</span> AbstractIterator <span class="op">{</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">};</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AbstractIterator <span class="op">{</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int</span> <span class="op">&amp;</span><span class="kw">operator</span><span class="op">*()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> AbstractIterator <span class="op">&amp;</span><span class="kw">operator</span><span class="op">++()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="kw">operator</span> <span class="op">!=</span> <span class="op">(</span><span class="at">const</span> AbstractIterator <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Set <span class="op">{</span></span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb184-20"><a href="#cb184-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb184-21"><a href="#cb184-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">class</span> Iterator<span class="op">:</span> <span class="kw">public</span> AbstractIterator <span class="op">{</span></span>
<span id="cb184-22"><a href="#cb184-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">...</span></span>
<span id="cb184-23"><a href="#cb184-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb184-24"><a href="#cb184-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Then you can write code that operates over iterators.</p>
<div class="sourceCode" id="cb185" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> for_each<span class="op">(</span>AbstractIterator <span class="op">&amp;</span>start<span class="op">,</span> AbstractIterator <span class="op">&amp;</span>finish<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>f<span class="op">)(</span><span class="dt">int</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>start <span class="op">!=</span> finish<span class="op">)</span> <span class="op">{</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(*</span>start<span class="op">);</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>start<span class="op">;</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a><span class="co">// to f to all the things</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Works over lists and sets.</p>
<p><u>Observer Pattern</u></p>
<p>Publish — subscribe model</p>
<p>One class: publisher/subject — generates data. One or more
subscriber/observer classes — receive data and react to it.</p>
<p><u>Eg</u> subject = spreadsheet cells, observers = graphs</p>
<ul>
<li><p>when cells change, graphs update</p></li>
</ul>
<p>Can be many different kinds of observer objects — subject should not
have to know all the details.</p>
<p><u>Observer Pattern</u></p>
<p>Sequence of method calls:</p>
<ol>
<li><p>Subject’s state is updated.</p></li>
<li><p>Subject::notifyObservers() — calls each observer’s
notify</p></li>
<li><p>Each observer calls ConcreteSubject::getState to query the state
&amp; reacts accordingly</p></li>
</ol>
<p><u>Example</u>: Horse races</p>
<p>Subject — publishes winners</p>
<p>Observers — individual bettors — declare victory when their horse
wins.</p>
<p>Subject class</p>
<div class="sourceCode" id="cb186" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Subject <span class="op">{</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>Observer<span class="op">*&gt;</span> observers<span class="op">;</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> attatch<span class="op">(</span>Observer <span class="op">*</span>ob<span class="op">)</span> <span class="op">{</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>            observers<span class="op">.</span>emplace_back<span class="op">(</span>ob<span class="op">);</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> detach<span class="op">(</span>Observer <span class="op">*</span>ob<span class="op">)</span> <span class="op">{</span></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// remove from observers</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// exercise (in lec folder)</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> notifyObservers<span class="op">()</span> <span class="op">{</span></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> ob<span class="op">:</span> observers<span class="op">)</span> <span class="op">{</span></span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>                ob<span class="op">-&gt;</span>notify<span class="op">();</span></span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>Subject<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>Subject<span class="op">::~</span>Subject<span class="op">()</span> <span class="op">{}</span></span></code></pre></div>
<p>Observer class</p>
<div class="sourceCode" id="cb187" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Observer <span class="op">{</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">void</span> notify<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>Observer<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb188" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HorseRace<span class="op">:</span> <span class="kw">public</span> Subject <span class="op">{</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>    ifstream in<span class="op">;</span> <span class="co">// source of data</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    string lastWinner<span class="op">;</span> <span class="co">// state</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a>    HorseRace<span class="op">(</span>string fname<span class="op">):</span> in<span class="op">{</span>fname<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> runRace<span class="op">()</span>  <span class="op">{</span></span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>        in <span class="op">&gt;&gt;</span> lastWinner<span class="op">;</span></span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!</span>in<span class="op">.</span>fail<span class="op">();</span></span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-10"><a href="#cb188-10" aria-hidden="true" tabindex="-1"></a>    string getState<span class="op">()</span> <span class="op">{</span></span>
<span id="cb188-11"><a href="#cb188-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lastWinner<span class="op">;</span></span>
<span id="cb188-12"><a href="#cb188-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-13"><a href="#cb188-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// concrete subject</span></span>
<span id="cb188-14"><a href="#cb188-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb188-15"><a href="#cb188-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-16"><a href="#cb188-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bettor<span class="op">:</span> <span class="kw">public</span> Observer <span class="op">{</span></span>
<span id="cb188-17"><a href="#cb188-17" aria-hidden="true" tabindex="-1"></a>    HorseRace <span class="op">*</span>subject<span class="op">;</span></span>
<span id="cb188-18"><a href="#cb188-18" aria-hidden="true" tabindex="-1"></a>    string name<span class="op">,</span> myHorse<span class="op">;</span></span>
<span id="cb188-19"><a href="#cb188-19" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb188-20"><a href="#cb188-20" aria-hidden="true" tabindex="-1"></a>    Bettor <span class="op">(</span>HorseRace <span class="op">*</span>hr<span class="op">,</span> string name<span class="op">,</span> string horse<span class="op">):</span></span>
<span id="cb188-21"><a href="#cb188-21" aria-hidden="true" tabindex="-1"></a>    subject<span class="op">{</span>hr<span class="op">},</span> name<span class="op">{</span>name<span class="op">},</span> myHorse<span class="op">{</span>horse<span class="op">}</span> <span class="op">{</span></span>
<span id="cb188-22"><a href="#cb188-22" aria-hidden="true" tabindex="-1"></a>        subject<span class="op">-&gt;</span>attach<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb188-23"><a href="#cb188-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-24"><a href="#cb188-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Bettor<span class="op">()</span> <span class="op">{</span></span>
<span id="cb188-25"><a href="#cb188-25" aria-hidden="true" tabindex="-1"></a>        subject<span class="op">-&gt;</span>detach<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb188-26"><a href="#cb188-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-27"><a href="#cb188-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> notify<span class="op">()</span> <span class="op">{</span></span>
<span id="cb188-28"><a href="#cb188-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>subject<span class="op">-&gt;</span>getState<span class="op">()</span> <span class="op">==</span> myHorse<span class="op">)</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;win!&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb188-29"><a href="#cb188-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb188-30"><a href="#cb188-30" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">&quot;lose&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb188-31"><a href="#cb188-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb188-32"><a href="#cb188-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-33"><a href="#cb188-33" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>main</u>:</p>
<div class="sourceCode" id="cb189" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>HorseRace hr <span class="op">{</span><span class="st">&quot;name.txt&quot;</span><span class="op">};</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>Bettor Larry <span class="op">(&amp;</span>hr<span class="op">,</span> <span class="st">&quot;Larry&quot;</span><span class="op">,</span> <span class="st">&quot;RunsLikeACow&quot;</span><span class="op">);</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ... (other bettors)</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>hr<span class="op">.</span>runRace<span class="op">())</span> <span class="op">{</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>    hr<span class="op">.</span>notifyObservers<span class="op">();</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-17">Lecture 17</h1>
<p><u>Decorator Pattern</u></p>
<p>Want to enhance an object at runtime — add
functionality/features.</p>
<p><u>Eg</u> Windowing system</p>
<ul>
<li><p>start with a basic window</p></li>
<li><p>add scrollbar</p></li>
<li><p>add menu</p></li>
</ul>
<p>Want to choose these enhancements at runtime.</p>
<p>Component — defines the interface — operations your objects will
provide</p>
<p>Concrete Component — implements the interface</p>
<p>Decorators — all inherit from Decorator, which inherits from
Component.</p>
<p>Therefore every Decorator <u>is</u> a Component <u>and</u> every
Decorator <u>HAS</u> a Component.</p>
<p><u>Eg</u> Window w/scrollbar <u>is</u> a kind of window and
<u>has</u> a pointer to the underlying plain window.</p>
<p>Window w/scrollbar and menu <u>is</u> a window, has a pointer to the
window w/scrollbar, which has a pointer to window. (similar to linked
list).</p>
<p>All inherit from Abstract Window, so Window methods can be use
polymorphically on all of them.</p>
<p><u>Eg</u> Pizza.</p>
<div class="sourceCode" id="cb190" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Pizza <span class="op">{</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">float</span> price<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> string desc<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Pizza<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb191" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> crustAndSauce<span class="op">:</span> <span class="kw">public</span> Pizza <span class="op">{</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> price<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span><span class="op">{</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">5.99</span><span class="op">;</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    string desc<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;Pizza&quot;</span><span class="op">;</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb192" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Decorator<span class="op">:</span> <span class="kw">public</span> Pizza <span class="op">{</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    Pizza <span class="op">*</span>component<span class="op">;</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    Decorator<span class="op">(</span>Pizza <span class="op">*</span>p<span class="op">):</span> component <span class="op">{</span>p<span class="op">}{}</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Decorator<span class="op">()</span> <span class="op">{</span><span class="kw">delete</span> component<span class="op">;}</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb193" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> StuffedCrust<span class="op">:</span> <span class="kw">public</span> Decorator <span class="op">{</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    StuffedCrust <span class="op">(</span>Pizza <span class="op">*</span>p<span class="op">):</span> Decorator<span class="op">{</span>p<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> price<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> component<span class="op">-&gt;</span>price<span class="op">()</span> <span class="op">+</span> <span class="fl">2.69</span><span class="op">;</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>    string desc<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> component<span class="op">-&gt;</span>desc<span class="op">()</span> <span class="op">+=</span> <span class="st">&quot; with stuffed crust&quot;</span><span class="op">;</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Topping<span class="op">:</span> <span class="kw">public</span> Decorator <span class="op">{</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>    string theTopping<span class="op">;</span></span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span> </span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>        Topping<span class="op">(</span>string topping<span class="op">,</span> Pizza <span class="op">*</span>p<span class="op">):</span> Decorator<span class="op">{</span>p<span class="op">},</span> theTopping<span class="op">{</span>topping<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb193-16"><a href="#cb193-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> price<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span> </span>
<span id="cb193-17"><a href="#cb193-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> component<span class="op">-&gt;</span>price<span class="op">()</span> <span class="op">+</span> <span class="fl">0.75</span><span class="op">;</span> </span>
<span id="cb193-18"><a href="#cb193-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb193-19"><a href="#cb193-19" aria-hidden="true" tabindex="-1"></a>        string desc<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span> </span>
<span id="cb193-20"><a href="#cb193-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> component<span class="op">-&gt;</span>desc<span class="op">()</span> <span class="op">+</span> <span class="st">&quot; with &quot;</span> <span class="op">+</span> theTopping<span class="op">;</span> </span>
<span id="cb193-21"><a href="#cb193-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb193-22"><a href="#cb193-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Client Code.</p>
<p><u>User</u>:</p>
<div class="sourceCode" id="cb194" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>Pizza <span class="op">*</span>p1 <span class="op">=</span> <span class="kw">new</span> CrustAndSauce<span class="op">;</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> <span class="kw">new</span> Topping<span class="op">{</span>p1<span class="op">,</span> <span class="st">&quot;cheese&quot;</span><span class="op">};</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> <span class="kw">new</span> Topping<span class="op">{</span>p1<span class="op">,</span> <span class="st">&quot;mushrooms&quot;</span><span class="op">};</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> <span class="kw">new</span> StuffedCrust<span class="op">{</span>p1<span class="op">};</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> p1<span class="op">-&gt;</span>desc<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&lt;&lt;</span> p1<span class="op">-&gt;</span>price<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> p1<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb195" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>v<span class="op">[</span>i<span class="op">]</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ith element of v</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="co">// unchecked -- if you go out of bounds, UB</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a><span class="co">// checked version of v[i]</span></span></code></pre></div>
<p>What happens when you go out of bounds? What should happen?</p>
<p><u>Problem</u> Vector’s code can detect the error, but doesn’t know
what to do about it. Client can respond, but can’t detect the error.</p>
<p><u>C Solution</u>: Functions return a status code or sets the global
variable errno. Leads to awkward programming. Encourages programmers to
ignore error-checks.</p>
<p><u>Exceptions</u></p>
<p>C++ — when an error condition arises, the function <u>raises an
exception</u>. What happens? By default, execution stops.</p>
<p>But we can write <u>handlers</u> to <u>catch</u> errors &amp; deal
with them.</p>
<p>vector&lt;T&gt;::at throws an exception of type std::out.of.range
when it fails. We can handle it as follows.</p>
<div class="sourceCode" id="cb196" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>stdexcept<span class="op">&gt;;</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> <span class="op">{</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> v<span class="op">.</span>at<span class="op">(</span><span class="dv">10000</span><span class="op">);</span> <span class="co">// stmts that may throw go in a try block</span></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span>out<span class="op">.</span>of<span class="op">.</span>range r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Range error.&quot;</span> <span class="op">&lt;&lt;</span> r<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now consider:</p>
<div class="sourceCode" id="cb197" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> out<span class="op">.</span>of<span class="op">.</span>range<span class="op">{</span><span class="st">&quot;f&quot;</span><span class="op">};</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// what .what() will say.</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">()</span> <span class="op">{</span>f<span class="op">();}</span></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h<span class="op">()</span> <span class="op">{</span>g<span class="op">();}</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">()</span> <span class="op">{</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span><span class="op">{</span></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a>        h<span class="op">();</span></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span><span class="op">(</span>out_of_range<span class="op">)</span> <span class="op">{</span></span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>What happens? Main calls h, h calls g, g calls f, f throws
out-of-range.</p>
<p>Control goes back through the call chain (unwinding the stack) until
a handler is found.</p>
<p>All the way back to main, main handles the exception.</p>
<p>No matching handler in the entire call chain <span
class="math inline">→</span> program terminates.</p>
<p>A handler might do part of the recovery job, i.e execute some
corrective code.</p>
<h1 class="unnumbered" id="lecture-18">Lecture 18</h1>
<p><u>Recall</u>: An exception can do part of the recovery job, throw
another exception.</p>
<div class="sourceCode" id="cb198" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> <span class="op">{---}</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span><span class="op">(</span>SomeError s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> SomeOtherError <span class="op">{};</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Or rethrow the same exception.</p>
<div class="sourceCode" id="cb199" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span><span class="op">{---}</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span><span class="op">(</span>SomeError s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb200" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="co">// throw; vs throw s;</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a><span class="cf">throw</span> s<span class="op">;</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a><span class="co">// s may be a subtype fo SomeError</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a><span class="co">// throws a new exception of type SomeError</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a><span class="co">//[SomeError]</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a><span class="co">//↑</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a><span class="co">//[SpecialError]</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a><span class="cf">throw</span><span class="op">;</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a><span class="co">// actual type of s is retained.</span></span></code></pre></div>
<p>A handler can act as a catch-all.</p>
<div class="sourceCode" id="cb201" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span><span class="op">{---}</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span>  <span class="co">// actually ...</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a><span class="co">// don&#39;t worry about the type of exception</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a><span class="op">---</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You can throw anything you want — don’t have to be objects.</p>
<p>When new fails: throws std::bad_alloc. <u>Never</u> let a destructor
throw or propagate an exception.</p>
<ul>
<li><p>Program will abort <u>immediately</u></p></li>
<li><p>If you want a throwing destructor, you can tag it with
noexcept(false).</p></li>
</ul>
<p><u>But</u> — if a destructor throws during stack unwinding while
dealing with another exception, you know have <u>two</u> active,
unhandled exceptions, &amp; the program <u>will</u> abort
immediately.</p>
<p>Much more to come.</p>
<p><u>Factory Method Pattern</u></p>
<p>Write a video game with 2 kinds of enemies: turtles &amp;
bullets.</p>
<ul>
<li><p>System randomly sends turtles &amp; bullets. Bullets more common
in harder levels.</p></li>
</ul>
<p>(factory.jpeg here)</p>
<ul>
<li><p>Never know exactly which enemy comes next, so can’t call
turtle/bullet directly.</p></li>
<li><p>Instead, put a factory method in Level that creates enemies.</p>
<ul>
<li><p>Method that "creates things"</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb202" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Level <span class="op">{</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> Enemy <span class="op">*</span>createEnemy<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is a factory method</span></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Easy<span class="op">:</span> <span class="kw">public</span> Level <span class="op">{</span></span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>    Enemy <span class="op">*</span>createEnemy<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// create mostly turtles </span></span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb202-13"><a href="#cb202-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-14"><a href="#cb202-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Hard<span class="op">:</span> <span class="kw">public</span> Level <span class="op">{</span></span>
<span id="cb202-15"><a href="#cb202-15" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb202-16"><a href="#cb202-16" aria-hidden="true" tabindex="-1"></a>    Enemy <span class="op">*</span>createEnemy<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb202-17"><a href="#cb202-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// create mostly bullets</span></span>
<span id="cb202-18"><a href="#cb202-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb202-19"><a href="#cb202-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb202-20"><a href="#cb202-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-21"><a href="#cb202-21" aria-hidden="true" tabindex="-1"></a>Level <span class="op">*</span>l <span class="op">=</span> <span class="kw">new</span> Easy<span class="op">;</span></span>
<span id="cb202-22"><a href="#cb202-22" aria-hidden="true" tabindex="-1"></a>Enemy <span class="op">*</span>c <span class="op">=</span> l<span class="op">-&gt;</span>createEnemy<span class="op">();</span></span></code></pre></div>
<p><u>Template Method Pattern</u></p>
<ul>
<li><p>Want subclasses to override superclass behaviour, but some
aspects must stay the same.</p></li>
</ul>
<p><u>Eg</u></p>
<p>There are red turtles &amp; green turtles.</p>
<div class="sourceCode" id="cb203" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Turtle <span class="op">{</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> draw<span class="op">()</span> <span class="op">{</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>        drawHead<span class="op">();</span></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>        drawShell<span class="op">();</span></span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>        drawFeet<span class="op">();</span></span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> drawHead<span class="op">()</span> <span class="op">{...}</span></span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> drawFeet<span class="op">(){...}</span></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> drawShell<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// drawShell is virtual</span></span>
<span id="cb203-13"><a href="#cb203-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it is only one that can be overriden</span></span>
<span id="cb203-14"><a href="#cb203-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb203-15"><a href="#cb203-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RedTurtle<span class="op">:</span> <span class="kw">public</span> Turtle <span class="op">{</span></span>
<span id="cb203-16"><a href="#cb203-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> drawShell<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb203-17"><a href="#cb203-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// draw red shell</span></span>
<span id="cb203-18"><a href="#cb203-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb203-19"><a href="#cb203-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb203-20"><a href="#cb203-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GreenTurtle<span class="op">:</span> <span class="kw">public</span> Turtle <span class="op">{</span></span>
<span id="cb203-21"><a href="#cb203-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> drawShell<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb203-22"><a href="#cb203-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// draw green shell</span></span>
<span id="cb203-23"><a href="#cb203-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb203-24"><a href="#cb203-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Subclasses can’t change the way a turtle is drawn (head, shell,
feet), but can change the way the shell is drawn.</p>
<p>Generalization: the Non-Virtual Interface (NVI) idiom.</p>
<ul>
<li><p>A public virtual method is really two things:</p>
<ul>
<li><p>public:</p>
<ul>
<li><p>an interface to the client</p></li>
<li><p>promises certain behaviour with pre/post conditions.</p></li>
</ul></li>
<li><p>virtual:</p>
<ul>
<li><p>an interface to subclasses</p></li>
<li><p>behaviour can be replaced with anything the subclass
wants</p></li>
</ul></li>
</ul></li>
</ul>
<p>Public &amp; virtual <span class="math inline">→</span> making
promises you can’t keep!</p>
<p><u>NVI says</u>:</p>
<ul>
<li><p><u>All</u> public methods should be non-virtual.</p></li>
<li><p><u>All</u> virtual methods should be private or
protected</p></li>
<li><p>except the destructor</p></li>
</ul>
<div class="sourceCode" id="cb204" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DigitalMedia <span class="op">{</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> play<span class="op">()=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a><span class="co">// public virtual method (no NVI)</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DigitalMedia <span class="op">{</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> play<span class="op">()</span> <span class="op">{</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can insert code here that checks first</span></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i.e checkCopyright()</span></span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// doPlay could be put in an if statement</span></span>
<span id="cb204-12"><a href="#cb204-12" aria-hidden="true" tabindex="-1"></a>        doPlay<span class="op">();</span></span>
<span id="cb204-13"><a href="#cb204-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can also make things happen after </span></span>
<span id="cb204-14"><a href="#cb204-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i.e update playcount</span></span>
<span id="cb204-15"><a href="#cb204-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb204-16"><a href="#cb204-16" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="cb204-17"><a href="#cb204-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> doPlay<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb204-18"><a href="#cb204-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb204-19"><a href="#cb204-19" aria-hidden="true" tabindex="-1"></a><span class="co">// public method that calls private virtual method</span></span></code></pre></div>
<p>Generalizes Template Method</p>
<ul>
<li><p><u>every</u> virtual method should be called from within a
template method.</p></li>
</ul>
<p><u>STL Maps — for creating dictionaries</u></p>
<p><u>Eg</u> "arrays" that map strings to integers</p>
<div class="sourceCode" id="cb205" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>map<span class="op">&gt;</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span> m<span class="op">;</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>m<span class="op">[</span><span class="st">&quot;abc&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a><span class="co">// maps abc to 2</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>m<span class="op">[</span><span class="st">&quot;def&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> m<span class="op">[</span><span class="st">&quot;ghi&quot;</span><span class="op">]</span> <span class="op">&lt;&lt;</span> m<span class="op">[</span><span class="st">&quot;def&quot;</span><span class="op">];</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 0 , 3</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a><span class="co">// m[ghi] gets inserted (because not present)</span></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a><span class="co">// value gets default constructed</span></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a><span class="co">// for ints that is 0</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-19">Lecture 19</h1>
<p>Recall:</p>
<div class="sourceCode" id="cb206" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>map<span class="op">&lt;</span>string<span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span>m<span class="op">;</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>m<span class="op">[</span><span class="st">&quot;abc&quot;</span><span class="op">]=</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>m<span class="op">[</span><span class="st">&quot;def&quot;</span><span class="op">]=</span><span class="dv">3</span><span class="op">;</span></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> m<span class="op">[</span><span class="st">&quot;ghi&quot;</span><span class="op">];</span> <span class="co">// 0</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> m<span class="op">[</span><span class="st">&quot;def&quot;</span><span class="op">];</span> <span class="co">// 3</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>m<span class="op">.</span>erase<span class="op">(</span><span class="st">&quot;abc&quot;</span><span class="op">);</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>m<span class="op">.</span>count<span class="op">(</span><span class="st">&quot;def&quot;</span><span class="op">))</span> <span class="co">// 0 = not found, 1 = found</span></span></code></pre></div>
<p>Iterating over a map <span class="math inline">→</span> sorted key
order.</p>
<div class="sourceCode" id="cb207" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>p <span class="op">:</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> p<span class="op">.</span>first <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&lt;&lt;</span> p<span class="op">.</span>second <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      key             value</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//first and second are fields</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>p’s type is std::pair&lt;string,int&gt; (&lt;utility&gt;)</p>
<p>std::pair is implemented as a struct, not as a class. Fields are
public.</p>
<p>In general: using ’class’ implies you are making an abstraction, with
invariants that must be maintained.</p>
<p>Struct signals that this is purely a conglomeration of values, no
invariants, all field values valid.</p>
<p>Alternatively:</p>
<div class="sourceCode" id="cb208" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;[</span>key<span class="op">,</span>value<span class="op">]:</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">//^ called a structured binding</span></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> key <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Structured bindings can be used on any structure(class) type with all
fields public:</p>
<p><u>Eg</u></p>
<div class="sourceCode" id="cb209" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>Vec v <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span>y<span class="op">]=</span>v<span class="op">;</span> <span class="co">// x = 1, y = 2</span></span></code></pre></div>
<p>Or on a stack array of known size:</p>
<div class="sourceCode" id="cb210" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span>y<span class="op">,</span>z<span class="op">]</span> <span class="op">=</span> a<span class="op">;</span> <span class="co">// x=1, y=2,z=3</span></span></code></pre></div>
<p><u>What should go into a module?</u></p>
<p>So far — each class gets its own module.</p>
<p>But a module can contain any # of classes &amp; functions.</p>
<p>When should classes/functions be grouped together in a module and
when should they be in separate modules?</p>
<p>Two <u>measures of design quality</u> — coupling &amp; cohesion.</p>
<p>Coupling — how much distinct program modules depend on each
other.</p>
<ul>
<li><p>low:</p>
<ul>
<li><p>modules communicate via function calls with basic parameters and
results</p></li>
<li><p>modules pass arrays/structs back &amp; forth</p></li>
<li><p>modules affect each other’s control flow</p></li>
<li><p>modules share global data</p></li>
</ul></li>
<li><p>high:</p>
<ul>
<li><p>modules have access to each other’s implementation
(friends)</p></li>
</ul></li>
</ul>
<p>High coupling <span class="math inline">→</span> changes to one
module require greater changes to other modules. Harder to reuse
individual modules.</p>
<p>Cohesion — how closely elements of a module are related to each
other.</p>
<ul>
<li><p>low:</p>
<ul>
<li><p>arbitrary grouping of unrelated elements (e.g.
&lt;utility&gt;)</p></li>
<li><p>elements share a common theme, otherwise unrelated, maybe some
common base code (e.g. &lt;algorithm&gt;)</p></li>
<li><p>elements manipulate state over the lifetime of an object (e.g.
open/read/close files)</p></li>
<li><p>elements pass data to each other</p></li>
</ul></li>
<li><p>high:</p>
<ul>
<li><p>elements cooperate to perform exactly one task</p></li>
</ul></li>
</ul>
<p>Low cohesion <span class="math inline">→</span> poorly organized code
— can’t reuse one part without getting other stuff bundled with it —
hard to understand, maintain.</p>
<p>Goal: low coupling, high cohesion.</p>
<p><u>Special case</u>: What if 2 classes depend on each other?</p>
<div class="sourceCode" id="cb211" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>    B y<span class="op">;</span></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb211-6"><a href="#cb211-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> x<span class="op">;</span></span>
<span id="cb211-7"><a href="#cb211-7" aria-hidden="true" tabindex="-1"></a>    A u<span class="op">;</span></span>
<span id="cb211-8"><a href="#cb211-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Impossible. How big would A &amp; B be?</p>
<p><u>But</u></p>
<div class="sourceCode" id="cb212" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">;</span> <span class="co">// forward-declare B</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>    B <span class="op">*</span>y<span class="op">;</span></span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compiler doesn&#39;t know what B is yet</span></span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> x<span class="op">;</span></span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a>    A xy<span class="op">;</span></span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Sometimes one class <u>must</u> come before the other.</p>
<p><u>Eg</u></p>
<div class="sourceCode" id="cb213" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">{...};</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> D<span class="op">:</span> <span class="kw">public</span> C <span class="op">{...};</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> E <span class="op">{</span>C a<span class="op">};</span></span></code></pre></div>
<p>Need to know the size of C to construct D &amp; E. C must come
first.</p>
<p><u>Q</u>: How should A &amp; B be placed into modules?</p>
<p><u>A</u>: Modules must be compiled in dependency order. One module
can’t forward declare another module, nor any item within that module.
Therefore, A &amp; B must be in the same module.</p>
<p>(Makes sense, since A &amp; B are obviously tightly coupled).</p>
<p><u>Decoupling the Interface (MVC)</u></p>
<p>Your primary program classes should not be printing things.</p>
<p><u>E.g</u></p>
<div class="sourceCode" id="cb214" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ChessBoard <span class="op">{</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Your move&quot;</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Bad design — inhibits code reuse.</p>
<p>What if you want to reuse ChessBoard, but not have it communicate via
cout?</p>
<p>One solution: parameterize the class by a stream:</p>
<div class="sourceCode" id="cb215" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Chessboard <span class="op">{</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>    istream <span class="op">&amp;</span>in<span class="op">;</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    ostream <span class="op">&amp;</span>out<span class="op">;</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>        ChessBoard<span class="op">(</span>istream <span class="op">&amp;</span>in<span class="op">,</span> ostream <span class="op">&amp;</span>out<span class="op">):</span> in<span class="op">{</span>in<span class="op">},</span> out<span class="op">{</span>out<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>        out <span class="op">&lt;&lt;</span> <span class="st">&quot;Your Move&quot;</span><span class="op">;</span>    </span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Still suffers from the same problem. Better — but what if we don’t
want to use streams at all?</p>
<p>Your chessboard class should not be communicating with users at
all.</p>
<p><u>Single Responsibility Principle:</u> "A class should have only one
reason to change"</p>
<p>I.e if <span class="math inline"> ≥ 2</span> distinct prats of the
problem specification affect the same class , then the class is doing
too much.</p>
<p>Each class should do only <u>one</u> job — game state &amp;
communication are <u>two</u> jobs.</p>
<p><u>Better</u>:</p>
<ul>
<li><p>Communicate with ChessBoard via params/results/exns.</p></li>
<li><p>Confine user communication to outside the game class</p></li>
</ul>
<p><u>Q</u>: Should main do the talking?</p>
<p><u>A</u>: No. Hard to reuse or replace code if it is in main</p>
<p>Should have a class to manage communication, that is separate from
the game state class.</p>
<p><u>Architecture</u>: Model-View-Controller (MVC)</p>
<p>Separate the distinct notions of the data (or state — "model") the
presentation of data ("view") and control or manipulation of the data
("controller").</p>
<p>Model:</p>
<ul>
<li><p>Can have multiple views (e.g. Text &amp; graphics)</p></li>
<li><p>Doesn’t need to know their details</p></li>
<li><p>Classic Observer pattern (or could communicate through the
controller)</p></li>
</ul>
<h1 class="unnumbered" id="lecture-20">Lecture 20</h1>
<p>Recall: MVC</p>
<p>Controller:</p>
<ul>
<li><p>Mediates control flow through model &amp; view</p></li>
<li><p>May encapsulate turn-taking, or full game rules</p></li>
<li><p>May communicate with the user for input (or this could be the
view)</p></li>
</ul>
<p><u>Exception Safety</u></p>
<p>Consider:</p>
<div class="sourceCode" id="cb216" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>    C c<span class="op">;</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    C <span class="op">*</span>p <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    g<span class="op">();</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> p<span class="op">;</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>No leaks — but what if g throws?</p>
<p>What is guaranteed?</p>
<ul>
<li><p>During stack-unwinding all stack-allocated data is cleaned up —
destructors run, memory is reclaimed</p></li>
<li><p>Heap-allocated memory is not reclaimed</p></li>
</ul>
<p>Therefore, if g throws, C is not leaked, but *p is.</p>
<div class="sourceCode" id="cb217" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>    C c<span class="op">;</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    C <span class="op">*</span>p <span class="op">=</span> <span class="kw">new</span> C<span class="op">;</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>        g<span class="op">();</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> p<span class="op">;</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> p<span class="op">;</span></span>
<span id="cb217-12"><a href="#cb217-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Error-Prone duplication of code. How else can we guarantee that
something (eg delete p) will happen, no matter how we exit f? (normal or
by exn)?</p>
<p>In some languages — "finally" clauses guarantee certain final actions
— not in C++. Only thing you can count in in C++ — destructors for
stack-allocated data will run. Therefore use stack-allocated data with
destructors as much as possible. Use the guarantee to your
advantage.</p>
<p><u>C++ Idiom</u>: RAII — Resource Acquisition Is Initialization</p>
<p>Every resource should be wrapped in a stack-allocated object, whose
job it is to delete it.</p>
<p><u>Eg</u> <u>Files</u></p>
<div class="sourceCode" id="cb218" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>ifstream f<span class="op">{</span><span class="st">&quot;file&quot;</span><span class="op">};</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Acquiring the resource ("file") = initializing the object(f)</p>
<p>The file is guaranteed to be released when f is popped from the stack
(f’s destructor runs)</p>
<p>This can be done with dynamic memory.</p>
<div class="sourceCode" id="cb219" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="co">//(import &lt;memory&gt;)</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">std::</span>unique<span class="op">-</span>pointer_ptr<span class="op">&lt;</span>T<span class="op">&gt;</span></span></code></pre></div>
<ul>
<li><p>Takes a T* in the constructor</p></li>
<li><p>The destructor will delete the pointer</p></li>
<li><p>In between — can dereference, just like a pointer</p></li>
</ul>
<div class="sourceCode" id="cb220" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>    C c<span class="op">;</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;</span> p <span class="op">{</span><span class="kw">new</span> C<span class="op">};</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    g<span class="op">();</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>No leaks guaranteed</p>
<p><u>Alternative</u></p>
<div class="sourceCode" id="cb221" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>    C c<span class="op">;</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>c<span class="op">&gt;();</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                          ctor args go here, if any</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>    g<span class="op">();</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Allocates a C object on the heap, and puts a pointer to it inside a
unique pointer to object.</p>
<p><u>Difficulty:</u></p>
<div class="sourceCode" id="cb222" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;</span> p <span class="op">{</span><span class="kw">new</span> C<span class="op">};</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;</span>q <span class="op">=</span> p<span class="op">;</span></span></code></pre></div>
<p>What would happen if a unique_ptr were copied?</p>
<p>Don’t want to delete the same pointer twice.</p>
<p>Instead — copying is disabled for unique_ptrs. They can only be
moved.</p>
<div class="sourceCode" id="cb223" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">class</span> unique_ptr <span class="op">{</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>    exlpicit unique_ptr<span class="op">(</span>T <span class="op">*</span>p<span class="op">):</span> ptr<span class="op">{</span>p<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>unique_ptr<span class="op">()</span> <span class="op">{</span><span class="kw">delete</span> ptr<span class="op">};</span></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>    unique_ptr<span class="op">(</span><span class="at">const</span> unique_ptr <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a>    unique_ptr<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;</span><span class="kw">operator</span><span class="op">(</span><span class="at">const</span> unique_ptr <span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>    unique_ptr<span class="op">(</span>unique_ptr <span class="op">&amp;&amp;</span>other<span class="op">):</span> ptr <span class="op">{</span>other<span class="op">.</span>ptr<span class="op">}</span> <span class="op">{</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>        other<span class="op">.</span>ptr <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a>    unique_ptr<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span>unique_ptr <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> ptr<span class="op">;</span></span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a>        ptr<span class="op">=</span>other<span class="op">.</span>ptr<span class="op">;</span></span>
<span id="cb223-15"><a href="#cb223-15" aria-hidden="true" tabindex="-1"></a>        other<span class="op">.</span>ptr <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb223-16"><a href="#cb223-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb223-17"><a href="#cb223-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb223-18"><a href="#cb223-18" aria-hidden="true" tabindex="-1"></a>    T <span class="op">&amp;</span><span class="kw">operator</span><span class="op">*()</span> <span class="op">{</span><span class="cf">return</span> <span class="op">*</span>ptr<span class="op">;}</span></span>
<span id="cb223-19"><a href="#cb223-19" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span>get<span class="op">()</span> <span class="op">{</span><span class="cf">return</span> ptr<span class="op">;}</span></span>
<span id="cb223-20"><a href="#cb223-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>If you need to be able to copy pointers — first answer the question
of <u>ownership</u>. Who will own the resource? who will have
responsibility for freeing it?</p>
<ul>
<li><p>That pointer should be a unique_ptr. All other pointers should be
raw pointers (can fetch the underlying raw pointer with
p.get()).</p></li>
</ul>
<p>New understanding of pointers:</p>
<ul>
<li><p>unique_ptr — indicates <u>ownership</u> — delete will happen
automatically when the unique_pointers go out of scope.</p></li>
<li><p>raw pointer — indicates <u>non-ownership</u>. Since a raw pointer
is considered not to own the resource it points at and you should not
delete it.</p></li>
</ul>
<p>Moving a unique_ptr = transfer of ownership.</p>
<p>Pointers as parameters</p>
<div class="sourceCode" id="cb224" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;</span> p<span class="op">);</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a><span class="co">// f will take ownership of the object pointered to by p</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a><span class="co">// caller loses custody of the object</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">(</span>C <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a><span class="co">//g will not take over ownership of the object pointed to by p</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a><span class="co">// caller&#39;s ownership of the object does not change</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a><span class="co">//Note that the caller might not own the object</span></span></code></pre></div>
<p>Pointers as results:</p>
<div class="sourceCode" id="cb225" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;</span> f<span class="op">();</span></span></code></pre></div>
<p>Return by value is always a move, so f is <u>handing over
ownership</u> of the C object to the caller.</p>
<div class="sourceCode" id="cb226" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>C <span class="op">*</span>g<span class="op">();</span></span></code></pre></div>
<p>The pointer returned by g is understood not to be deleted by the
caller, so it might represent a pointer to non-heap data, or to heap
data that someone else already owns.</p>
<p>Rarely, a situation may arise that calls for true <u>shared
ownership</u>, i.e. any of several pointers might need to free the
resource.</p>
<ul>
<li><p>use std::shared_ptr</p></li>
</ul>
<div class="sourceCode" id="cb227" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>c<span class="op">&gt;</span> <span class="op">();</span></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(---)</span> <span class="op">{</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> q <span class="op">=</span>p<span class="op">;</span></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// q popped, pointer not deleted</span></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// p is popped, pointer is deleted</span></span></code></pre></div>
<p>Shared pointers maintain a <u>reference-count</u> of all shared_ptrs
pointing at the same object.</p>
<p>Memory is freed when the # of shared_ptrs pointing to it will reach
0.</p>
<p>Recall (Racket)</p>
<pre class="racket" data-frame="lines" data-linenos=""
data-fontsize="\large"><code>(define l1 (cons 1 (cons 2 (cons 3 empty))))
(define l2 (cons 4 (rest l1)))</code></pre>
<p>rest of l2 points to second element of l1</p>
<h1 class="unnumbered" id="lecture-21">Lecture 21</h1>
<p>Exception safety... What is exception safety?</p>
<p>It is <u>not</u></p>
<ul>
<li><p>exceptions never happen</p></li>
<li><p>all exceptions get handled</p></li>
</ul>
<p>It <u>is</u></p>
<ul>
<li><p>after an exception has been handled, the program is not left in a
broken or unusable state</p></li>
</ul>
<p>Specifically, 3 levels of exception safety for a function f:</p>
<ol>
<li><p>Basic guarantee — if an exception occurs, the program will be in
some valid state. Nothing is leaked no corrupted data structures, all
class invariants maintained.</p></li>
<li><p>Strong guarantee — if an exception is raised while executing f,
the state of the program will be as if f had not been called.</p></li>
<li><p>No-throw guarantee — f will never throw or propagate an exception
and will always accomplish its task.</p></li>
</ol>
<p><u>Eg</u></p>
<div class="sourceCode" id="cb229" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{...};</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">{...};</span></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span></span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>g<span class="op">();</span> <span class="co">//may throw (strong guarantee)</span></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>h<span class="op">()</span> <span class="co">//may throw (strong guarantee)</span></span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Is C::f exception safe?</p>
<ul>
<li><p>If a.g() throws — nothing has happened yet. OK.</p></li>
<li><p>If b.h() throws — effects of g would have to be undone to offer
the strong guarantee</p>
<ul>
<li><p>very hard or impossible if g has non-local side-effects</p></li>
</ul></li>
</ul>
<p>No, probably not exception safe.</p>
<p>If A::g and B::h do not have non-local side effects, can use copy
&amp; swap.</p>
<div class="sourceCode" id="cb230" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>        A atemp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>        B btemp <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>        atemp<span class="op">.</span>g<span class="op">();</span></span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a>        btemp<span class="op">.</span>h<span class="op">();</span></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//if any of the above throw, the original a and b are still intact</span></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> atemp<span class="op">;</span></span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> btemp<span class="op">;</span></span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//What if copy assignment throws?</span></span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//In particular, what if a=atemp succeeds</span></span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//but b = btemp fails.</span></span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Better if swap was no-throw. <u>Recall</u> : copying pointers can’t
throw.</p>
<p><u>Solution</u>: Access C’s internal state through a pointer (called
the <u>pimpl</u> idiom).</p>
<div class="sourceCode" id="cb231" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> CImpl <span class="op">{</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>    unique_ptr<span class="op">&lt;</span>CImpl<span class="op">&gt;</span> pImpl<span class="op">;</span></span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb231-9"><a href="#cb231-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> tmp <span class="op">=</span> make_unique<span class="op">&lt;</span>CImpl<span class="op">&gt;(*</span>pImpl<span class="op">);</span></span>
<span id="cb231-10"><a href="#cb231-10" aria-hidden="true" tabindex="-1"></a>        tmp<span class="op">-&gt;</span>a<span class="op">.</span>g<span class="op">();</span></span>
<span id="cb231-11"><a href="#cb231-11" aria-hidden="true" tabindex="-1"></a>        tmp<span class="op">-&gt;</span>b<span class="op">.</span>h<span class="op">();</span></span>
<span id="cb231-12"><a href="#cb231-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>pImpl<span class="op">,</span> tmp<span class="op">);</span> <span class="co">// no-throw</span></span>
<span id="cb231-13"><a href="#cb231-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb231-14"><a href="#cb231-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>If either A::g or B::h offer no exception safety, then neither can
f.</p>
<p><u>Exception Safety &amp; the STL — Vectors</u></p>
<p>Vectors — encapsulate a heap-allocated array</p>
<ul>
<li><p>follow RAII — when a stack-allocated vector goes out of scope,
the internal heap array is freed.</p></li>
</ul>
<div class="sourceCode" id="cb232" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>c<span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// V goes out of scope, array is freed, C dtor runs</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a><span class="co">// on all objects in the vector</span></span></code></pre></div>
<p><u>But</u></p>
<div class="sourceCode" id="cb233" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">()</span> <span class="op">{</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>c<span class="op">*&gt;</span> v<span class="op">;</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span>  </span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// array is freed, ptrs don&#39;t have dtors, and objects</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ptd to by the ptrs are not deleted.</span></span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a><span class="co">// v is not considered to own these objects.</span></span></code></pre></div>
<p><u>But</u></p>
<div class="sourceCode" id="cb234" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h<span class="op">()</span> <span class="op">{</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;&gt;</span>v<span class="op">;</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// array is freed, unique_ptr dtors run</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a><span class="co">// the objects are deleted</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a><span class="co">// no specific deallocation</span></span></code></pre></div>
<div class="sourceCode" id="cb235" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>c<span class="op">&gt;</span> <span class="co">// owns the object</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>c<span class="op">*&gt;</span> <span class="co">// does not own the object </span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>unique_ptr<span class="op">&lt;</span>c<span class="op">&gt;&gt;</span> <span class="co">// owns the object</span></span></code></pre></div>
<div class="sourceCode" id="cb236" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>emplace_back <span class="co">// offers the strong guarantee</span></span></code></pre></div>
<ul>
<li><p>If the array is full (i.e size == cap)</p>
<ul>
<li><p>allocate new array</p></li>
<li><p>copy objects over (copy ctor)</p>
<ul>
<li><p>if a copy ctor throws*</p>
<ul>
<li><p>destroy the new array</p></li>
<li><p>old array still intact</p></li>
<li><p>strong guarantee</p></li>
</ul></li>
</ul></li>
<li><p>delete old array (no throw)</p></li>
</ul></li>
</ul>
<p>*<u>But</u> — copying is expensive &amp; the old array will be thrown
away. Wouldn’t moving the objects be more efficient?</p>
<ul>
<li><p>allocate the new array</p></li>
<li><p><u>move</u> the objects over (move ctor)</p>
<ul>
<li><p>if move constructor throws</p>
<ul>
<li><p>original is no longer intact</p></li>
<li><p>can’t offer the strong guarantee</p></li>
</ul></li>
</ul></li>
<li><p>delete the old array (no-throw)</p></li>
</ul>
<p>If the move constructor offers the no-throw guarantee, emplace_back
will use the move constructor. Otherwise it will use the copy
constructor, which may be slower.</p>
<p>So your move operations should offer the no-throw guarantee, and you
should indicate that they do:</p>
<div class="sourceCode" id="cb237" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>    C <span class="op">(</span>C <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{...}</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>    C <span class="op">&amp;</span><span class="kw">operator</span><span class="op">=(</span>C <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{...}</span></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>If you know a function will never throw or propagate an exception,
declare it noexcept. Facilitates optimization.</p>
<p>At minimum: moves &amp; swaps should be noexcept.</p>
<p><u>Casting</u></p>
<p>In C:</p>
<div class="sourceCode" id="cb238" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>Node n<span class="op">;</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>ip <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)&amp;</span>n<span class="op">;</span> <span class="co">//cast - forces C++ to treat</span></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a><span class="co">// a Node * as an int*</span></span></code></pre></div>
<p>C-style casts should be avoided in C++.</p>
<p>If you <u>must</u> cast, use a C++ style cast:</p>
<p><u>4 kinds</u></p>
<ol>
<li><p>Static_cast — "sensible casts" — casts with a well-defined
semantics.</p></li>
</ol>
<p><u>Eg</u> double <span class="math inline">→</span> int</p>
<div class="sourceCode" id="cb239" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> d<span class="op">;</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">double</span> d<span class="op">);</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>d<span class="op">));</span></span></code></pre></div>
<p>superclass ptr <span class="math inline">→</span> subclass ptr</p>
<div class="sourceCode" id="cb240" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>b <span class="op">=</span> <span class="kw">new</span> Text <span class="op">{...};</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a>Text <span class="op">*</span>t <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Text<span class="op">*&gt;(</span>b<span class="op">);</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-22">Lecture 22</h1>
<p><u>Recall</u>: Superclass <span class="math inline">→</span> subclass
pointer</p>
<div class="sourceCode" id="cb241" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>b <span class="op">=</span> <span class="kw">new</span> Text<span class="op">{...};</span></span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>Text <span class="op">*</span>t <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Text<span class="op">*&gt;(</span>b<span class="op">);</span></span></code></pre></div>
<p>Taking responsibility that b actually points to a Text. "Trust
me".</p>
<ol>
<li><p>Static_cast — "sensible casts" — casts with a well-defined
semantics.</p></li>
<li><p>Reinterpret_cast — unsafe, implementation-specific, "weird"
casts</p>
<div class="sourceCode" id="cb242" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a>Student s<span class="op">;</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>Turtle <span class="op">*</span>t <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>Turtle<span class="op">*&gt;(&amp;</span>s<span class="op">);</span></span></code></pre></div></li>
<li><p>Const_cast — for converting between const &amp; non-const — the
only C++ cast that can "cast away const".</p></li>
</ol>
<div class="sourceCode" id="cb243" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p<span class="op">);</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a><span class="co">// suppose we know that under the circumstances in which f operates</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a><span class="co">// g won&#39;t modify *p</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> <span class="op">*</span>p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a>    g<span class="op">(</span><span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;(</span>p<span class="op">));</span></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol>
<li><p>Static_cast — "sensible casts" — casts with a well-defined
semantics.</p></li>
<li><p>Reinterpret_cast — unsafe, implementation-specific, "weird"
casts.</p></li>
<li><p>Const_cast — for converting between const &amp; non-const — the
only C++ cast that can "cast away const".</p></li>
<li><p>Dynamic_cast — Is it safe to convert a Book * to a Text
*?</p></li>
</ol>
<div class="sourceCode" id="cb244" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>pb ___<span class="op">;</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a><span class="kw">static_cast</span><span class="op">&lt;</span>Text <span class="op">*&gt;(</span>pb<span class="op">)</span> <span class="co">// safe?</span></span></code></pre></div>
<p>Depends on what pb actually points to. Better to do a tentative cast
— try it &amp; see if it succeeds.</p>
<div class="sourceCode" id="cb245" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>Text <span class="op">*</span>pt <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Text<span class="op">*&gt;(</span>pb<span class="op">);</span></span></code></pre></div>
<p>If the cast works (*pb really is a Text, or a subclass of Text), pt
points to the object.</p>
<p>If not — pt will be nullptr.</p>
<div class="sourceCode" id="cb246" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>pt<span class="op">)</span> cout <span class="op">&lt;&lt;</span> pt<span class="op">-&gt;</span>getTopic<span class="op">();</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Not a text.&quot;</span><span class="op">;</span></span></code></pre></div>
<p>These are options on raw pointers. Can we do them with smart
pointers?</p>
<p>Yes — static_pointer_cast, etc. Cast shared_ptrs to shared_ptrs.</p>
<p>Dynamic_casting also works with refs:</p>
<div class="sourceCode" id="cb247" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>Text t <span class="op">{</span>___<span class="op">};</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a>Book <span class="op">&amp;</span>b <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>Text <span class="op">&amp;</span>t2 <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Text <span class="op">&amp;&gt;(</span>b<span class="op">);</span></span></code></pre></div>
<p>If b "points to" a Text, then t2 is a reference to the same Text.</p>
<p>If not <span class="math inline">…</span> ? (No such thing as a null
reference). Throws std::bad_cast.</p>
<p><u>Note</u>: Dynamic casting only works on classes with at least one
virtual method.</p>
<p>Dynamic reference casting offers a possible solution to the
polymorphic assignment problem:</p>
<div class="sourceCode" id="cb248" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>Text <span class="op">&amp;</span>Text<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Book <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span> <span class="co">// virtual</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Text <span class="op">&amp;</span>tother <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span><span class="at">const</span> Text<span class="op">&amp;&gt;(</span>other<span class="op">);</span></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// throws if other is not a Text</span></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>    Book<span class="op">::</span><span class="kw">operator</span><span class="op">=(</span>other<span class="op">);</span></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>    topic <span class="op">=</span> tother<span class="op">-&gt;</span>topic<span class="op">;</span></span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Is dynamic casting good style?</p>
<p>Can use dynamic casting to make decisions based on an object’s
runtime type information (RTTI)</p>
<div class="sourceCode" id="cb249" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> whatIsIt<span class="op">(</span>Book <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Comic<span class="op">*&gt;(</span>b<span class="op">))</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Comic&quot;</span><span class="op">;</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Text<span class="op">*&gt;(</span>b<span class="op">))</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Text&quot;</span><span class="op">;</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>b<span class="op">)</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Book&quot;</span><span class="op">;</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Nothing&quot;</span><span class="op">;</span></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Code like this is <u>tightly coupled</u> to the Book hierarchy, and
may indicate bad design.</p>
<p><u>Why?</u> What if you create a new kind of Book?</p>
<ul>
<li><p>WhatIsIt doesn’t work anymore until you add a clause for the book
type.</p></li>
<li><p>Must do this wherever you are dynamic casting</p></li>
</ul>
<p>Better: use virtual methods</p>
<p><u>Note</u>: Text::operator= does not have this problem (only need to
compare with your own type, not all the types in the hierarchy).</p>
<p>So dynamic casting isn’t always bad design.</p>
<p>How can we fix whatIsIt?</p>
<div class="sourceCode" id="cb250" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Book <span class="op">{</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> identify<span class="op">()</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Book&quot;</span><span class="op">;}</span>  </span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> whatIsIt<span class="op">(</span>Book <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>b<span class="op">)</span> b<span class="op">-&gt;</span>identify<span class="op">();</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;nothing&quot;</span><span class="op">;</span></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Works by having an interface function that is uniform across all Book
types. What if the interface isn’t uniform across the hierarchy?</p>
<p>Inheritance &amp; virtual methods work well when</p>
<ul>
<li><p>There is an unlimited number of potential specializations of a
basic abstraction.</p></li>
<li><p>Each following the same interface</p></li>
</ul>
<p>But what about the opposite case</p>
<ul>
<li><p>Small number of specializations, all known in advance, unlikely
to change</p></li>
<li><p>With different interfaces</p></li>
</ul>
<p>In the first case — new subclass <span class="math inline">→</span>
no effort at all</p>
<p>In the second case — new subclass <span class="math inline">→</span>
rework existing code to accommodate the new interface, but that’s fine
because you are not expecting to add new subclasses <span
class="math inline">…</span> or you are expecting to put in that
effort.</p>
<p><u>Eg</u></p>
<div class="sourceCode" id="cb251" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Turtle<span class="op">:</span> publicEnemy <span class="op">{</span></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> stealShell<span class="op">();</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bullet publicEnemy <span class="op">{</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> deflect<span class="op">();</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Interfaces not uniform. A new enemy type is going to mean a new
interface &amp; unavoidable work. So we could regard the set of Enemy
classes as fixed, and maybe dynamic casting is justified.</p>
<p><u>But</u>: in this case, maybe inheritance is the wrong tool. If you
know that the enemy will only be a Turtle or Bullet, and you accept the
work that comes with adding new Enemy types, then consider:</p>
<div class="sourceCode" id="cb252" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">&lt;</span>variant<span class="op">&gt;;</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> variant <span class="op">&lt;</span>Turtle<span class="op">,</span>Bullet<span class="op">&gt;</span> Enemy<span class="op">;</span></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a><span class="co">// equiv:</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Enemy <span class="op">=</span> variant <span class="op">&lt;</span>Turtle<span class="op">,</span>Bullet<span class="op">&gt;</span></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a><span class="co">// An Enemy is a Turtle or a Bullet. Period.</span></span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a>Enemy e <span class="op">{</span>Turtle<span class="op">{}};</span> <span class="co">// or bullet</span></span>
<span id="cb252-7"><a href="#cb252-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>holds<span class="op">.</span>alternative<span class="op">&lt;</span>Turtle<span class="op">&gt;(</span>e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb252-8"><a href="#cb252-8" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Turtle&quot;</span><span class="op">;</span></span>
<span id="cb252-9"><a href="#cb252-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">...</span></span></code></pre></div>
<h1 class="unnumbered" id="lecture-23">Lecture 23</h1>
<p><u>Recall</u>:</p>
<div class="sourceCode" id="cb253" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Enemy <span class="op">=</span> variant<span class="op">&lt;</span>Turtle<span class="op">,</span>Bullet<span class="op">&gt;;</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>Enemy e <span class="op">{</span>Turtle<span class="op">{}};</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Discriminating the value</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>holds_alternative<span class="op">&lt;</span>Turtle<span class="op">&gt;(</span>e<span class="op">))</span> <span class="op">{</span></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Turtle&quot;</span><span class="op">;</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">...</span></span></code></pre></div>
<div class="sourceCode" id="cb254" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Executing the value:</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> <span class="op">{</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>    Turtle t <span class="op">=</span> get<span class="op">&lt;</span>Turtle<span class="op">&gt;(</span>e<span class="op">);</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//use t...</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span>bad_variant_access f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it&#39;s not a Turtle...</span></span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A variant is like a union but type-safe. Attempting to store as one
type &amp; fetch as another will throw.</p>
<p>If a variant is left uninitialized, the first option in the variant
is default-constructed to initialize the variant.</p>
<p>Compiler error if first option is not default-constructible.</p>
<p>Options:</p>
<ol>
<li><p>Make the first option a type that has a default ctor.</p></li>
<li><p>Don’t leave your variant uninitialized.</p></li>
<li><p>Use std::monostate as the first option. "Dummy" type that can be
used as default.</p>
<ol>
<li><p>Can be used to create an "optional" type: <u>e.g.</u>
variant&lt;monostate,T&gt; = "T or nothing". (Also:
std::optional&lt;T&gt;).</p></li>
</ol></li>
</ol>
<p><u>How Virtual Methods Work</u></p>
<div class="sourceCode" id="cb255" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vec <span class="op">{</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{...}</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vec2 <span class="op">{</span></span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">()</span> <span class="op">{...}</span></span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a>Vec v<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a>Vec2 w<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">};</span> <span class="co">// Do these two look the same in memory</span></span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&lt;&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>w<span class="op">);</span></span>
<span id="cb255-13"><a href="#cb255-13" aria-hidden="true" tabindex="-1"></a><span class="co">// 8  16 ???</span></span></code></pre></div>
<p><u>First note:</u></p>
<ul>
<li><p>8 is space for 2 integers. No space for f method</p></li>
<li><p>Compiler turns methods into ordinary functions &amp; separates
them.</p></li>
</ul>
<p><u>Recall:</u></p>
<div class="sourceCode" id="cb256" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a>Book <span class="op">*</span>pb <span class="op">=</span> <span class="kw">new</span><span class="op">{</span>Comic<span class="op">};</span> <span class="co">// among book, text, comic</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pb <span class="op">=</span> make_unique<span class="op">&lt;</span>Comic<span class="op">&gt;(...)</span> <span class="co">// per above choice</span></span></code></pre></div>
<p>isHeavy is virtual <span class="math inline">→</span> choice of which
version to run is based on the type of the actual object — which the
compiler won’t know in advance.</p>
<p><span class="math inline">∴</span> choice must be made at runtime.
How?</p>
<p>For each class with virtual methods, the compiler creates a table of
function pointers (the <u>vtable</u>).</p>
<div class="sourceCode" id="cb257" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>Class C<span class="op">{</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> g<span class="op">();</span></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h<span class="op">();</span></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>C<span class="op">();</span></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C objects have an extra pointer (the <u>vptr</u>) that points to C’s
vtable:</p>
<p>Calling a virtual method:</p>
<ul>
<li><p>follow vptr to vtable</p></li>
<li><p>fetch ptr to actual method from table</p></li>
<li><p>follow the function pointer &amp; call the function</p></li>
<li><p>(all of the above happens at run-time)</p></li>
</ul>
<p><span class="math inline">∴</span> virtual function calls incur a
small overhead cost in time.</p>
<p><u>Also</u>: Having <span class="math inline"> &gt;  = 1</span>
function adds a vptr to the object. <span class="math inline">∴</span>
classes with no virtual functions produce smaller obs than if some were
virtual — space cost.</p>
<p>Concretely, how is an object laid out? Compiler-dependent. Why did we
put the vptr first in the object and not somewhere else (e.g last)?</p>
<div class="sourceCode" id="cb258" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span>c<span class="op">;</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">();</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b<span class="op">,</span>d<span class="op">;</span></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>But...</u></p>
<p><u>Multiple Inheritance</u></p>
<p>A class can inherit from more than one class.</p>
<div class="sourceCode" id="cb259" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b<span class="op">;</span></span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> A<span class="op">,</span> <span class="kw">public</span> B <span class="op">{</span></span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true" tabindex="-1"></a> <span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb259-11"><a href="#cb259-11" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> a <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span> <span class="op">&lt;&lt;</span> b<span class="op">;</span></span>
<span id="cb259-12"><a href="#cb259-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb259-13"><a href="#cb259-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>B &amp; C inherit from A.</p>
<div class="sourceCode" id="cb260" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> D<span class="op">:</span> <span class="kw">public</span> B<span class="op">,</span> <span class="kw">public</span> C <span class="op">{</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> d<span class="op">;</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>D dobj<span class="op">;</span></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a>dobj<span class="op">.</span>a <span class="co">// which a is this? Amibiguous</span></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a><span class="co">// compiler error</span></span></code></pre></div>
<p>Need to specify dobj.B::a or dobj.C::a.</p>
<p>But if B &amp; C inherit from A, should there by one A part of D or
two? (Two is the default).</p>
<p>Should B::a, C::a be the same or different?</p>
<p>What if we want ("deadly diamond")</p>
<p>Make A a <u>virtual</u> base class — <u>virtual</u></p>
<div class="sourceCode" id="cb261" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">:</span> <span class="kw">virtual</span> <span class="kw">public</span> A <span class="op">{</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C<span class="op">:</span> <span class="kw">virtual</span> <span class="kw">public</span> A <span class="op">{</span></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><u>E.g.</u> IO stream hierarchy.</p>
<p>How would this be laid out?</p>
<p>Distance from class to parent is not constant. It
depends on the runtime type of object.</p>
<p><u>Solution</u>: Distance to the parent object is stored in the
vtable.</p>
<p>Diagram still doesn’t look like all of A,B,C,D simultaneously. But
slices of it do look like A,B,C,D.</p>
<p><span class="math inline">∴</span> pointer assignment among A,B,C,D
changes the address stored in the pointer.</p>
<div class="sourceCode" id="cb262" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">*</span>d <span class="op">=</span> <span class="kw">new</span> D<span class="op">;</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">*</span>a <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a><span class="co">// this changes the address (adds the distance)</span></span></code></pre></div>
<p>Static/dynamic cast will also do this, reinterpret_cast will not.</p>
<h1 class="unnumbered" id="lecture-24">Lecture 24</h1>
<div class="sourceCode" id="cb263" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> T min<span class="op">(</span>Tx<span class="op">,</span> Ty<span class="op">)</span> <span class="op">{</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">&lt;</span>y<span class="op">?</span> x <span class="op">:</span> y<span class="op">;</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> z <span class="op">=</span> min<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span> <span class="co">// C++ infers T = int from types</span></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of x and y</span></span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If C++ can’t determine T, you can tell it.</p>
<div class="sourceCode" id="cb264" data-frame="lines" data-linenos=""
data-fontsize="\large"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> z <span class="op">=</span> min<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>min<span class="op">(</span><span class="ch">&#39;a&#39;</span><span class="op">,</span><span class="ch">&#39;c&#39;</span><span class="op">)</span> <span class="co">// T = char</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>min<span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">);</span> <span class="co">// T = double</span></span></code></pre></div>
<p>For what types T can min be used? For what types T does the body
compile?</p>
<p>Any type for which operator &lt; is defined.</p>
</body>
</html>
